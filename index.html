<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ãƒ‰ãƒ­ãƒƒãƒ—ãƒ•ã‚¡ã‚¤ãƒ–</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tensorflow/4.10.0/tf.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
        }

        .card {
            background: white;
            border-radius: 10px;
            padding: 12px; /* 20px â†’ 12px ã«å‰Šæ¸› */
            margin-bottom: 15px; /* 20px â†’ 15px ã«å‰Šæ¸› */
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        .start-screen {
            text-align: center;
            padding: 40px;
        }

        .game-title {
            font-size: 3em;
            color: #333;
            margin-bottom: 20px;
        }

        .rules {
            text-align: left;
            margin: 20px 0;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .rules ul {
            margin: 10px 0;
            padding-left: 20px;
        }

        .rules li {
            margin: 8px 0;
        }

        .btn {
            background: linear-gradient(135deg, #8b5cf6 0%, #ec4899 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 8px;
            font-size: 18px;
            cursor: pointer;
            transition: transform 0.2s;
            margin: 10px;
        }

        .btn:hover {
            transform: translateY(-2px);
        }

        .btn.ai-mode {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
        }

        

        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .game-status {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .players {
            display: flex;
            gap: 30px;
        }

        .player {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 18px;
        }

        .player.active {
            font-weight: bold;
        }

        .player.ai {
            font-style: italic;
        }

        .player-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
        }

        .red { background: #ef4444; }
        .blue { background: #3b82f6; }

        .timer {
            font-size: 24px;
            font-weight: bold;
        }

        .timer.warning {
            color: #ef4444;
            animation: blink 1s infinite;
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            font-size: 14px;
            color: #666;
        }

       ã€€        .grid-container {
            text-align: center;
            padding: 15px;
            overflow-x: auto;
            overflow-y: hidden;
            background: white;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            margin-bottom: 0;
            
            /* ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«å¯¾å¿œ */
            -webkit-overflow-scrolling: touch;
            scrollbar-width: thin;
            scrollbar-color: #8b5cf6 #f1f1f1;
        }

        .grid-container::-webkit-scrollbar {
            height: 8px;
        }

        .grid-container::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }

        .grid-container::-webkit-scrollbar-thumb {
            background: #8b5cf6;
            border-radius: 4px;
        }
      .grid {
            display: inline-grid;
            grid-template-columns: repeat(15, 56px); /* 48px â†’ 56px ã«æ‹¡å¤§ */
            gap: 2px;
            background: #ddd;
            padding: 10px;
            border-radius: 8px;
            min-width: max-content;
            border: 3px solid transparent;
            transition: border-color 0.5s ease, box-shadow 0.5s ease;
            margin: 0 auto;
        }

        .cell {
            width: 56px; /* 48px â†’ 56px ã«æ‹¡å¤§ */
            height: 56px;
            background: white;
            border: 3px solid transparent;
            box-sizing: border-box;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px; /* 24px â†’ 28px ã«æ‹¡å¤§ */
            transition: all 0.3s;
        }


        .cell:hover {
            background: #f0f0f0;
            border-color: #ddd;
        }

        .cell.ground {
            background: #fef3c7;
            border-bottom-color: #d97706;
        }

        .cell.red {
            background: #ef4444;
            color: white;
            border-color: #dc2626;
        }

        .cell.red::before {
            content: 'â—';
            font-size: 20px;
            font-weight: bold;
        }

        .cell.blue {
            background: #3b82f6;
            color: white;
            border-color: #2563eb;
        }

        .cell.blue::before {
            content: 'â—';
            font-size: 20px;
            font-weight: bold;
        }

        .cell.winning {
            border-color: #fbbf24;
            animation: winningBlink 1s infinite;
            box-shadow: 0 0 10px #fbbf24;
        }

        .cell.dropping {
            animation: drop 0.5s ease-out;
        }

        .ground-label {
            margin-top: 15px;
            color: #d97706;
            font-weight: bold;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
        }

        .modal-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 40px;
            border-radius: 10px;
            text-align: center;
            max-width: 400px;
            width: 90%;
        }

        .winner-icon {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            margin: 0 auto 20px;
        }

        .alert {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #ef4444;
            color: white;
            padding: 15px 25px;
            border-radius: 8px;
            font-weight: bold;
            z-index: 1001;
            animation: alertShow 0.3s ease-out;
        }

        .game-main {
            display: flex;
            gap: 20px;
            align-items: flex-start;
        }

        .game-field {
            flex: 1;
            text-align: center;
        }

        .game-sidebar {
            width: 200px;
            background: rgba(255,255,255,0.9);
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .timer-display {
            text-align: center;
            padding: 10px;
            background: rgba(255,255,255,0.9);
            border-radius: 10px;
            margin-bottom: 15px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .timer-display .timer {
            font-size: 36px; /* 24px â†’ 36px ã«æ‹¡å¤§ */
            font-weight: bold;
            margin: 0;
        }

        .sidebar-section {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #e5e7eb;
        }

        .sidebar-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }

        .sidebar-title {
            font-size: 14px;
            font-weight: bold;
            color: #666;
            margin-bottom: 8px;
        }


        .blocks-info {
            font-size: 16px;
            text-align: center;
        }

        .blocks-remaining {
            font-size: 24px;
            font-weight: bold;
            color: #8b5cf6;
        }
        

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.5; }
        }

        @keyframes winningBlink {
            0%, 100% { 
                border-color: #fbbf24;
                box-shadow: 0 0 10px #fbbf24;
            }
            50% { 
                border-color: #f59e0b;
                box-shadow: 0 0 20px #f59e0b;
            }
        }

        @keyframes drop {
            0% { transform: translateY(-20px); opacity: 0.7; }
            100% { transform: translateY(0); opacity: 1; }
        }

        @keyframes turnFlash {
            0% { transform: scale(1); opacity: 1; }
            30% { transform: scale(1.3); opacity: 0.8; }
            60% { transform: scale(1); opacity: 1; }
            100% { transform: scale(1); opacity: 1; }
        }

        .player.flash {
            animation: turnFlash 0.8s ease-out;
            color: #fbbf24;
        }

        @keyframes alertShow {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
            100% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }

       
        
        /* ã‚¿ãƒ–ãƒ¬ãƒƒãƒˆå¯¾å¿œ */
        @media (max-width: 768px) {
            .game-main {
                flex-direction: column;
                gap: 15px;
            }
            
            .game-sidebar {
                width: 100%;
                display: flex;
                justify-content: space-around;
                padding: 10px;
            }
            
            .sidebar-section {
                margin-bottom: 0;
                padding-bottom: 0;
                border-bottom: none;
                text-align: center;
            }
            
            .grid {
                grid-template-columns: repeat(15, 28px);
            }
            
            .cell {
                width: 28px;
                height: 28px;
                font-size: 18px;
            }
            
            .cell.red::before,
            .cell.blue::before {
                font-size: 12px;
            }
        }

        /* ã‚¹ãƒãƒ›å¯¾å¿œ */
        @media (max-width: 600px) {
            .container {
                padding: 10px;
            }
            
            .card {
                padding: 8px;
                margin-bottom: 10px;
            }
            
            .grid {
                grid-template-columns: repeat(15, 20px);
                gap: 1px;
                padding: 6px;
            }
            
            .cell {
                width: 20px;
                height: 20px;
                font-size: 14px;
                border-width: 2px;
            }
            
            .cell.red::before,
            .cell.blue::before {
                font-size: 10px;
            }
            
            .timer-display .timer {
                font-size: 28px;
            }
            
            .current-player-display {
                font-size: 16px;
            }
            
            .blocks-remaining {
                font-size: 20px;
            }
        }

        /* å°ã•ã„ã‚¹ãƒãƒ›å¯¾å¿œ */
        @media (max-width: 480px) {
            .grid {
                grid-template-columns: repeat(15, 16px);
                gap: 1px;
                padding: 4px;
            }
            
            .cell {
                width: 16px;
                height: 16px;
                font-size: 12px;
                border-width: 1px;
            }
            
            .cell.red::before,
            .cell.blue::before {
                font-size: 8px;
            }
        }
        

        

        /* LEVEL6å°‚ç”¨ã‚¹ã‚¿ã‚¤ãƒ« */
        .ml-container {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
            color: white;
        }

        .ml-status {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .ml-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 5px;
        }

        .ml-indicator.loading { background: #fbbf24; animation: pulse 1s infinite; }
        .ml-indicator.training { background: #10b981; animation: pulse 1s infinite; }
        .ml-indicator.ready { background: #3b82f6; }
        .ml-indicator.error { background: #ef4444; }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(255,255,255,0.3);
            border-radius: 4px;
            overflow: hidden;
            margin: 5px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #10b981, #3b82f6);
            transition: width 0.3s ease;
        }

        .ml-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            font-size: 12px;
        }

        .stat-item {
            text-align: center;
            padding: 5px;
            background: rgba(255,255,255,0.1);
            border-radius: 5px;
        }

        .stat-value {
            font-weight: bold;
            font-size: 14px;
            display: block;
        }

        .ml-controls {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .ml-btn {
            background: rgba(255,255,255,0.2);
            border: 1px solid rgba(255,255,255,0.3);
            color: white;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .ml-btn:hover {
            background: rgba(255,255,255,0.3);
        }

        .ai-thinking {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            z-index: 1002;
            text-align: center;
        }

        .thinking-spinner {
            border: 3px solid rgba(255,255,255,0.3);
            border-top: 3px solid #3b82f6;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        
        /* æ–°ã—ã„ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼ */
        .current-player-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-left: 8px;
            border: 2px solid #333;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .current-player-indicator.active {
            opacity: 1;
            animation: currentPlayerPulse 1.5s ease-in-out infinite;
        }

        @keyframes currentPlayerPulse {
            0%, 100% { 
                transform: scale(1);
                box-shadow: 0 0 0 0 rgba(139, 92, 246, 0.7);
            }
            50% { 
                transform: scale(1.2);
                box-shadow: 0 0 0 4px rgba(139, 92, 246, 0);
            }
        }

        .player-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #e5e7eb;
        }

        .player-row:last-child {
            border-bottom: none;
        }

        .player-info {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        /* ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰æ ãƒã‚ªãƒ³æ¼”å‡º */
        .grid.player1-turn {
            border-color: #ef4444;
            box-shadow: 
                0 0 10px #ef4444,
                0 0 20px #ef4444,
                0 0 30px #ef4444,
                inset 0 0 10px rgba(239, 68, 68, 0.1);
            animation: redNeonPulse 2s ease-in-out;
        }

        .grid.player2-turn {
            border-color: #3b82f6;
            box-shadow: 
                0 0 10px #3b82f6,
                0 0 20px #3b82f6,
                0 0 30px #3b82f6,
                inset 0 0 10px rgba(59, 130, 246, 0.1);
            animation: blueNeonPulse 2s ease-in-out;
        }

        @keyframes redNeonPulse {
            0%, 100% { 
                box-shadow: 
                    0 0 5px #ef4444,
                    0 0 10px #ef4444,
                    0 0 15px #ef4444,
                    inset 0 0 5px rgba(239, 68, 68, 0.1);
            }
            50% { 
                box-shadow: 
                    0 0 15px #ef4444,
                    0 0 25px #ef4444,
                    0 0 35px #ef4444,
                    inset 0 0 15px rgba(239, 68, 68, 0.2);
            }
        }

        @keyframes blueNeonPulse {
            0%, 100% { 
                box-shadow: 
                    0 0 5px #3b82f6,
                    0 0 10px #3b82f6,
                    0 0 15px #3b82f6,
                    inset 0 0 5px rgba(59, 130, 246, 0.1);
            }
            50% { 
                box-shadow: 
                    0 0 15px #3b82f6,
                    0 0 25px #3b82f6,
                    0 0 35px #3b82f6,
                    inset 0 0 15px rgba(59, 130, 246, 0.2);
            }
        }
        
    </style>
</head>
<body>
    <div class="container">
        <!-- ã‚¹ã‚¿ãƒ¼ãƒˆç”»é¢ -->
        <div id="startScreen" class="card start-screen">
            <h1 class="game-title">ãƒ‰ãƒ­ãƒƒãƒ—ãƒ•ã‚¡ã‚¤ãƒ–</h1>
            <p>2äººå¯¾æˆ¦ãƒ–ãƒ­ãƒƒã‚¯é…ç½®ãƒ‘ã‚ºãƒ«ã‚²ãƒ¼ãƒ </p>
            
            <div class="rules">
                <h3>ğŸ“‹ ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ«</h3>
                <ul>
                    <li>å…ˆè¡Œãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®è‰²ã®ãƒ–ãƒ­ãƒƒã‚¯ãŒä¸­å¤®ã«1å€‹é…ç½®ã•ã‚Œã¾ã™</li>
                    <li>å…ˆè¡Œã¯åˆæ‰‹ã§1å€‹ã®ã¿é…ç½®å¯èƒ½</li>
                    <li>2ã‚¿ãƒ¼ãƒ³ç›®ä»¥é™ã¯å„ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒ1ã‚¿ãƒ¼ãƒ³ã«2å€‹é…ç½®</li>
                    <li>ç¸¦ãƒ»æ¨ªãƒ»æ–œã‚ã®ã„ãšã‚Œã‹ã§5å€‹é€£ç¶šã«ä¸¦ã¹ã‚‹ã¨å‹åˆ©</li>
                    <li>1éšï¼ˆåœ°é¢ï¼‰ã§ã¯éš£æ¥ã™ã‚‹ãƒ–ãƒ­ãƒƒã‚¯ãŒå¿…è¦</li>
                    <li>2éšä»¥ä¸Šã§ã¯éš£æ¥åˆ¶é™ãªã—</li>
                    <li>ãƒ–ãƒ­ãƒƒã‚¯ã¯é‡åŠ›ã§è‡ªå‹•çš„ã«è½ä¸‹</li>
                    <li>åˆ¶é™æ™‚é–“å†…ã«é…ç½®ã—ãªã„ã¨è² ã‘</li>
                </ul>
            </div>

            <!-- LEVEL6 AIçŠ¶æ³è¡¨ç¤º -->
            <div id="mlStatusContainer" class="ml-container" style="display: none;">
                <div class="ml-status">
                    <div>
                        <span class="ml-indicator loading" id="mlIndicator"></span>
                        <span id="mlStatusText">LEVEL6 AI åˆæœŸåŒ–ä¸­...</span>
                    </div>
                    <button class="ml-btn" id="mlToggleBtn" onclick="toggleMLTraining()">
                        å­¦ç¿’ãƒ¢ãƒ¼ãƒ‰: ON
                    </button>
                </div>
                
                <div class="progress-bar">
                    <div class="progress-fill" id="mlProgress" style="width: 0%"></div>
                </div>
                
              
                <div class="ml-stats">
                    <div class="stat-item">
                        <span class="stat-value" id="gamesCount">0</span>
                        <span>å¯¾æˆ¦æ•°</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-value" id="winRate">0%</span>
                        <span>å‹ç‡</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-value" id="explorationRate">100%</span>
                        <span>æ¢ç´¢ç‡</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-value" id="learningStage">æº–å‚™ä¸­</span>
                        <span>æˆé•·æ®µéš</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-value" id="latestLoss">---</span>
                        <span>å­¦ç¿’èª¤å·®</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-value" id="avgReward">---</span>
                        <span>å¹³å‡å ±é…¬</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-value" id="evolutionTrend">æº–å‚™ä¸­</span>
                        <span>é€²åŒ–å‚¾å‘</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-value" id="memoryCount">0</span>
                        <span>è¨˜æ†¶æ•°</span>
                    </div>
                </div>
                
               <div class="ml-controls">
                    <button class="ml-btn" id="resetMLBtn" onclick="resetMLAI()">AIãƒªã‚»ãƒƒãƒˆ</button>
                    <button class="ml-btn" id="exportMLBtn" onclick="exportMLData()">ãƒ‡ãƒ¼ã‚¿å‡ºåŠ›</button>
                    <button class="ml-btn" id="showGraphBtn" onclick="showLearningGraph()">å­¦ç¿’ã‚°ãƒ©ãƒ•</button>
                    <button class="ml-btn" id="saveMLBtn" onclick="saveMLManually()">æ‰‹å‹•ä¿å­˜</button>
                </div>
            </div>

            <div style="margin: 20px 0;">
                <label style="font-weight: bold; color: #333;">ğŸ¤– AIã®å¼·ã•ã‚’é¸ã¶ï¼š</label><br>
              <select id="aiLevelSelect" style="padding: 8px 16px; font-size: 16px; border-radius: 6px;" onchange="onAILevelChange()">
                    <option value="1">Lv1ï¼ˆå¹¼å…ãƒ¬ãƒ™ãƒ«ï¼‰</option>
                    <option value="2">Lv2ï¼ˆã‚¬ã‚­ãƒ¬ãƒ™ãƒ«ï¼‰</option>
                    <option value="3">Lv3ï¼ˆä¸­åŠãƒ¬ãƒ™ãƒ«ï¼‰</option>
                    <option value="4">Lv4ï¼ˆé–“ã®æ‚ªã„å¤§äººãƒ¬ãƒ™ãƒ«ï¼‰</option>
                    <option value="6">Lv6ï¼ˆè—¤äº•å£®å¤ªå¹¼å°‘æœŸãƒ¬ãƒ™ãƒ«ï¼‰ğŸ§ </option>
                </select>
            </div>
            
            <button class="btn" onclick="startGame(false)">ğŸ‘¥ 2äººå¯¾æˆ¦</button>
            <button class="btn ai-mode" onclick="startGame(true)">ğŸ¤– AIã¨å¯¾æˆ¦</button>
        </div>

        <!-- ã‚²ãƒ¼ãƒ ç”»é¢ -->
            <div id="gameScreen" class="game-screen">
                <!-- ãƒ˜ãƒƒãƒ€ãƒ¼ -->
                <div class="card">
                    <div class="game-header">
                        <h2>ãƒ‰ãƒ­ãƒƒãƒ—ãƒ•ã‚¡ã‚¤ãƒ–</h2>
                        <div>
                            <button class="btn" onclick="showStart()">æ–°ã—ã„ã‚²ãƒ¼ãƒ </button>
                            <button class="btn" onclick="endGameNow()" style="background: #dc2626; margin-left: 10px;">ã‚²ãƒ¼ãƒ çµ‚äº†</button>
                        </div>
                    </div>
                </div>

                <!-- ã‚¿ã‚¤ãƒãƒ¼è¡¨ç¤º -->
                <div class="timer-display">
                    <div class="timer" id="timer">5:00</div>
                </div>

                <!-- ãƒ¡ã‚¤ãƒ³ã‚²ãƒ¼ãƒ ã‚¨ãƒªã‚¢ -->
                <div class="card">
                    <div class="game-main">
                        <!-- ã‚²ãƒ¼ãƒ ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ -->
                        <div class="game-field">
                            <div class="grid" id="gameGrid"></div>
                            <div class="ground-label">â¬†ï¸ åœ°é¢ãƒ¬ãƒ™ãƒ«ï¼ˆéš£æ¥ãƒ–ãƒ­ãƒƒã‚¯å¿…è¦ï¼‰</div>
                        </div>

                        <!-- ã‚µã‚¤ãƒ‰ãƒãƒ¼ -->
                        <div class="game-sidebar">
                            <div class="sidebar-section">
                                <div class="sidebar-title">æ®‹ã‚Šãƒ–ãƒ­ãƒƒã‚¯</div>
                                <div class="blocks-info">
                                    <div class="blocks-remaining" id="remainingBlocks">1</div>
                                    <div>/ <span id="maxBlocks">1</span></div>
                                </div>
                            </div>

                            <div class="sidebar-section">
                                <div class="sidebar-title">ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼</div>
                                
                                <div class="player-row">
                                    <div class="player-info">
                                        <div class="player-color red"></div>
                                        <span id="player1Name">ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼1</span>
                                    </div>
                                    <div class="current-player-indicator red" id="player1Indicator"></div>
                                </div>
                                
                                <div class="player-row">
                                    <div class="player-info">
                                        <div class="player-color blue"></div>
                                        <span id="player2Name">ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼2</span>
                                    </div>
                                    <div class="current-player-indicator blue" id="player2Indicator"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

        <!-- ã‚²ãƒ¼ãƒ çµ‚äº†ãƒ¢ãƒ¼ãƒ€ãƒ« -->
        <div id="gameModal" class="modal">
            <div class="modal-content">
                <h2 id="modalTitle">ã‚²ãƒ¼ãƒ çµ‚äº†</h2>
                <div class="winner-icon" id="winnerIcon"></div>
                <p id="modalMessage">çµæœãƒ¡ãƒƒã‚»ãƒ¼ã‚¸</p>
                <button class="btn" onclick="startGame(false)">2äººå¯¾æˆ¦</button>
                <button class="btn ai-mode" onclick="startGame(true)">AIã¨å¯¾æˆ¦</button>
            </div>
        </div>
    </div>

    <!-- AIæ€è€ƒä¸­è¡¨ç¤º -->
    <div id="aiThinkingModal" class="ai-thinking" style="display: none;">
        <div class="thinking-spinner"></div>
        <div id="thinkingText">LEVEL6 AI æ€è€ƒä¸­...</div>
        <div id="thinkingDetails" style="font-size: 12px; margin-top: 10px; opacity: 0.8;"></div>
    </div>

    <script>
        // ã‚²ãƒ¼ãƒ è¨­å®š
        var GRID_WIDTH = 15;
        var GRID_HEIGHT = 12;
        var WIN_COUNT = 5;
        var BLOCKS_PER_TURN = 2;
        var aiLevel = 1;
        var level6AI = null;

        // ã‚²ãƒ¼ãƒ çŠ¶æ…‹
        var game = {
            grid: [],
            currentPlayer: 1,
            firstPlayer: 1,
            aiPlayer: null,
            remainingBlocks: 1,
            timeLeft: 30,
            gameActive: false,
            timer: null,
            animating: false,
            winningCells: [],
            showingWin: false,
            turnCount: 0,
            isAI: false,
            aiThinking: false
        };

        // LEVEL6 æ©Ÿæ¢°å­¦ç¿’AI
        // LEVEL6 æ©Ÿæ¢°å­¦ç¿’AI
        // LEVEL6 æ©Ÿæ¢°å­¦ç¿’AI
      // LEVEL6 æ©Ÿæ¢°å­¦ç¿’AI å®Ÿå­¦ç¿’ç‰ˆï¼ˆæœ¬å½“ã«å­¦ç¿’ã™ã‚‹ï¼‰
      // LEVEL6 æ©Ÿæ¢°å­¦ç¿’AI å®‰å®šä¿®æ­£ç‰ˆï¼ˆã‚¨ãƒ©ãƒ¼å®Œå…¨è§£æ±ºï¼‰
        class Level6AI {
            constructor() {
                this.isInitialized = false;
                this.isTraining = true;
                this.model = null;
                this.memory = [];
                this.gamesPlayed = 0;
                this.wins = 0;
                this.winRate = 0;
                this.epsilon = 1.0;
                this.epsilonMin = 0.1;
                this.epsilonDecay = 0.99;
                this.maxMemory = 500;
                this.batchSize = 16;
                
                // ã‚¿ãƒ¼ãƒ³ç®¡ç†
                this.currentTurn = null;
                this.gameExperiences = [];
                
                // çµ±è¨ˆãƒ»å¯è¦–åŒ–
                this.lossHistory = [];
                this.winRateHistory = [];
                this.rewardHistory = [];
                this.trainingCount = 0;
                
                // ä¿å­˜ã‚­ãƒ¼
                this.modelKey = 'localstorage://dropfive-ai-lv6-stable';
                this.statsKey = 'dropfive-ai-lv6-stable-stats';
                
                console.log("ğŸ§  å®‰å®šç‰ˆLevel6AIåˆæœŸåŒ–é–‹å§‹");
            }

            async initializeModel() {
                try {
                    this.showStatus('loading', 'å®‰å®šç‰ˆAIåˆæœŸåŒ–ä¸­...');
                    this.updateProgress(20);
                    
                    // ä¿å­˜ã•ã‚ŒãŸãƒ¢ãƒ‡ãƒ«ã®èª­ã¿è¾¼ã¿
                    await this.loadModel();
                    
                    if (!this.model) {
                        this.showStatus('loading', 'æ–°è¦ãƒ¢ãƒ‡ãƒ«æ§‹ç¯‰ä¸­...');
                        this.updateProgress(50);
                        this.createStableModel();
                        console.log("ğŸ§  æ–°è¦ãƒ¢ãƒ‡ãƒ«æ§‹ç¯‰å®Œäº†");
                    } else {
                        console.log("ğŸ“¥ ä¿å­˜æ¸ˆã¿ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿å®Œäº†");
                    }
                    
                    this.updateProgress(80);
                    
                    // çµ±è¨ˆãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿
                    this.loadStatistics();
                    console.log("ğŸ“Š çµ±è¨ˆãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿å®Œäº†");

                    this.isInitialized = true;
                    this.showStatus('ready', 'å®‰å®šç‰ˆAIæº–å‚™å®Œäº†');
                    this.updateProgress(100);
                    
                    // UIæ›´æ–°ã‚’æœ€å¾Œã«å®Ÿè¡Œ
                    this.updateUI();
                    
                    console.log("âœ… å®‰å®šç‰ˆLevel6AIåˆæœŸåŒ–å®Œäº†");
                    
                } catch (error) {
                    console.error("å®‰å®šç‰ˆAIåˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼:", error);
                    console.error("ã‚¨ãƒ©ãƒ¼è©³ç´°:", error.message || "è©³ç´°ä¸æ˜");
                    this.showStatus('error', 'AIåˆæœŸåŒ–å¤±æ•—');
                    
                    // æœ€å°é™ã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
                    try {
                        this.createMinimalModel();
                        this.isInitialized = true;
                        this.showStatus('ready', 'æœ€å°ç‰ˆAIæº–å‚™å®Œäº†');
                        console.log("âš ï¸ æœ€å°ãƒ¢ãƒ‡ãƒ«ã§å‹•ä½œé–‹å§‹");
                    } catch (fallbackError) {
                        console.error("ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å¤±æ•—:", fallbackError);
                        this.showStatus('error', 'AIå®Œå…¨å¤±æ•—');
                    }
                }
            }

            createStableModel() {
                try {
                    this.model = tf.sequential({
                        layers: [
                            tf.layers.dense({ 
                                inputShape: [180], 
                                units: 128, 
                                activation: 'relu'
                            }),
                            tf.layers.dropout({ rate: 0.3 }),
                            tf.layers.dense({ 
                                units: 64, 
                                activation: 'relu'
                            }),
                            tf.layers.dense({ 
                                units: 180, 
                                activation: 'linear'
                            })
                        ]
                    });

                    this.model.compile({
                        optimizer: tf.train.adam(0.001),
                        loss: 'meanSquaredError'
                    });
                } catch (error) {
                    console.error("å®‰å®šãƒ¢ãƒ‡ãƒ«ä½œæˆã‚¨ãƒ©ãƒ¼:", error);
                    throw error;
                }
            }

            createMinimalModel() {
                this.model = tf.sequential({
                    layers: [
                        tf.layers.dense({ 
                            inputShape: [180], 
                            units: 64, 
                            activation: 'relu'
                        }),
                        tf.layers.dense({ 
                            units: 180, 
                            activation: 'linear'
                        })
                    ]
                });

                this.model.compile({
                    optimizer: 'adam',
                    loss: 'meanSquaredError'
                });
            }

            async loadModel() {
                try {
                    this.model = await tf.loadLayersModel(this.modelKey);
                    console.log("ğŸ“¥ ä¿å­˜æ¸ˆã¿ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿æˆåŠŸ");
                } catch (error) {
                    console.log("ğŸ“ æ–°è¦ãƒ¢ãƒ‡ãƒ«ä½œæˆ");
                    this.model = null;
                }
            }

            async saveModel() {
                if (this.model && this.isInitialized) {
                    try {
                        await this.model.save(this.modelKey);
                        console.log("ğŸ’¾ ãƒ¢ãƒ‡ãƒ«ä¿å­˜å®Œäº†");
                    } catch (error) {
                        console.error("ğŸ’¾ ãƒ¢ãƒ‡ãƒ«ä¿å­˜ã‚¨ãƒ©ãƒ¼:", error);
                    }
                }
            }

            loadStatistics() {
                try {
                    const saved = localStorage.getItem(this.statsKey);
                    if (saved) {
                        const data = JSON.parse(saved);
                        this.gamesPlayed = data.gamesPlayed || 0;
                        this.wins = data.wins || 0;
                        this.winRate = data.winRate || 0;
                        this.epsilon = data.epsilon || 1.0;
                        this.lossHistory = data.lossHistory || [];
                        this.winRateHistory = data.winRateHistory || [];
                        this.trainingCount = data.trainingCount || 0;
                        console.log(`ğŸ“Š çµ±è¨ˆèª­ã¿è¾¼ã¿: ${this.gamesPlayed}æˆ¦, å‹ç‡${(this.winRate*100).toFixed(1)}%`);
                    }
                } catch (error) {
                    console.error("çµ±è¨ˆèª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:", error);
                    // ã‚¨ãƒ©ãƒ¼ã§ã‚‚ç¶šè¡Œ
                    this.gamesPlayed = 0;
                    this.wins = 0;
                    this.winRate = 0;
                }
            }

            saveStatistics() {
                try {
                    const data = {
                        gamesPlayed: this.gamesPlayed,
                        wins: this.wins,
                        winRate: this.winRate,
                        epsilon: this.epsilon,
                        lossHistory: this.lossHistory.slice(-100),
                        winRateHistory: this.winRateHistory.slice(-100),
                        trainingCount: this.trainingCount
                    };
                    localStorage.setItem(this.statsKey, JSON.stringify(data));
                } catch (error) {
                    console.error("çµ±è¨ˆä¿å­˜ã‚¨ãƒ©ãƒ¼:", error);
                }
            }

            startGame(gameState, currentPlayer) {
                this.gameExperiences = [];
                console.log(`ğŸ® ã‚²ãƒ¼ãƒ é–‹å§‹ - ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼${currentPlayer}`);
            }

            startTurn(gameState, currentPlayer) {
                this.currentTurn = {
                    player: currentPlayer,
                    startState: this.encodeState(gameState, currentPlayer),
                    actions: [],
                    rewards: []
                };
                console.log(`ğŸ¯ ã‚¿ãƒ¼ãƒ³é–‹å§‹ - ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼${currentPlayer}`);
            }

            recordAction(action, gameState, currentPlayer) {
                if (this.currentTurn && this.currentTurn.player === currentPlayer) {
                    this.currentTurn.actions.push(action);
                    
                    const immediateReward = this.calculateImmediateReward(gameState, currentPlayer, action);
                    this.currentTurn.rewards.push(immediateReward);
                    
                    console.log(`ğŸ“ è¡Œå‹•è¨˜éŒ² ${this.currentTurn.actions.length}/2: (${action[0]}, ${action[1]}) å ±é…¬:${immediateReward.toFixed(3)}`);
                }
            }

            endTurn(finalGameState, finalResult) {
                if (!this.currentTurn) return;
                
                if (this.currentTurn.actions.length > 0) {
                    const experience = {
                        state: this.currentTurn.startState,
                        actions: this.currentTurn.actions.slice(),
                        immediateRewards: this.currentTurn.rewards.slice(),
                        player: this.currentTurn.player,
                        timestamp: Date.now()
                    };
                    
                    this.gameExperiences.push(experience);
                    console.log(`ğŸ“‹ ã‚¿ãƒ¼ãƒ³çµŒé¨“ä¿å­˜: ${this.currentTurn.actions.length}æ‰‹, ç´¯è¨ˆå ±é…¬:${this.currentTurn.rewards.reduce((a,b)=>a+b,0).toFixed(3)}`);
                }

                this.currentTurn = null;
            }

            calculateImmediateReward(gameState, currentPlayer, action) {
                let reward = 0;
                const opponent = currentPlayer === 1 ? 2 : 1;
                const [row, col] = action;
                
                // é€£çµæ•°ãƒœãƒ¼ãƒŠã‚¹
                gameState.grid[row][col] = currentPlayer;
                const myConnections = this.countConnections(gameState, row, col, currentPlayer);
                
                if (myConnections >= 5) {
                    reward += 10.0;  // å‹åˆ©ç¢ºå®š
                } else if (myConnections >= 4) {
                    reward += 3.0;   // 4é€£
                } else if (myConnections >= 3) {
                    reward += 1.0;   // 3é€£
                } else if (myConnections >= 2) {
                    reward += 0.3;   // 2é€£
                }
                
                gameState.grid[row][col] = 0;
                
                // ç›¸æ‰‹é˜»æ­¢ãƒœãƒ¼ãƒŠã‚¹
                gameState.grid[row][col] = opponent;
                const opponentConnections = this.countConnections(gameState, row, col, opponent);
                
                if (opponentConnections >= 5) {
                    reward += 8.0;   // ç›¸æ‰‹å‹åˆ©é˜»æ­¢
                } else if (opponentConnections >= 4) {
                    reward += 2.0;   // ç›¸æ‰‹4é€£é˜»æ­¢
                } else if (opponentConnections >= 3) {
                    reward += 0.5;   // ç›¸æ‰‹3é€£é˜»æ­¢
                }
                
                gameState.grid[row][col] = 0;
                
                // ä¸­å¤®å„ªä½
                const centerCol = Math.floor(GRID_WIDTH / 2);
                const distanceFromCenter = Math.abs(col - centerCol);
                reward += Math.max(0, 0.1 - distanceFromCenter * 0.01);
                
                return reward;
            }

            countConnections(gameState, row, col, player) {
                const directions = [[0,1], [1,0], [1,1], [1,-1]];
                let maxConnection = 1;
                
                for (const [dr, dc] of directions) {
                    let count = 1;
                    
                    for (let i = 1; i < 5; i++) {
                        const r = row + dr * i;
                        const c = col + dc * i;
                        if (r >= 0 && r < GRID_HEIGHT && c >= 0 && c < GRID_WIDTH && 
                            gameState.grid[r] && gameState.grid[r][c] === player) {
                            count++;
                        } else break;
                    }
                    
                    for (let i = 1; i < 5; i++) {
                        const r = row - dr * i;
                        const c = col - dc * i;
                        if (r >= 0 && r < GRID_HEIGHT && c >= 0 && c < GRID_WIDTH && 
                            gameState.grid[r] && gameState.grid[r][c] === player) {
                            count++;
                        } else break;
                    }
                    
                    maxConnection = Math.max(maxConnection, count);
                }
                
                return maxConnection;
            }

            async onGameEnd(result, aiPlayer) {
                this.gamesPlayed++;
                
                if (result === 'win') {
                    this.wins++;
                }
                
                this.winRate = this.wins / this.gamesPlayed;
                this.winRateHistory.push(this.winRate);
                
                console.log(`ğŸ ã‚²ãƒ¼ãƒ çµ‚äº†: ${result} (${this.gamesPlayed}æˆ¦ç›®, å‹ç‡${(this.winRate*100).toFixed(1)}%)`);
                
                // æœ€çµ‚å ±é…¬è¨­å®š
                this.assignFinalRewards(result, aiPlayer);
                
                // å­¦ç¿’å®Ÿè¡Œ
                await this.trainAfterGame();
                
                // UIæ›´æ–°
                this.updateUI();
            }

            assignFinalRewards(result, aiPlayer) {
                if (this.gameExperiences.length === 0) {
                    console.log("âš ï¸ å­¦ç¿’ç”¨çµŒé¨“ãƒ‡ãƒ¼ã‚¿ãªã—");
                    return;
                }
                
                let finalReward = 0;
                if (result === 'win') {
                    finalReward = 5.0;
                } else if (result === 'lose') {
                    finalReward = -3.0;
                } else {
                    finalReward = 0.0;
                }
                
                console.log(`ğŸ–ï¸ æœ€çµ‚å ±é…¬è¨­å®š: ${finalReward} (çµæœ: ${result})`);
                
                for (let exp of this.gameExperiences) {
                    if (exp.player === aiPlayer) {
                        const totalReward = exp.immediateRewards.reduce((a, b) => a + b, 0) + finalReward;
                        
                        const finalExperience = {
                            state: exp.state,
                            actions: exp.actions,
                            reward: totalReward,
                            timestamp: exp.timestamp
                        };
                        
                        this.memory.push(finalExperience);
                        console.log(`ğŸ’¾ çµŒé¨“ä¿å­˜: ${exp.actions.length}æ‰‹, ç·å ±é…¬:${totalReward.toFixed(3)}`);
                    }
                }
                
                while (this.memory.length > this.maxMemory) {
                    this.memory.shift();
                }
                
                console.log(`ğŸ“Š ç¾åœ¨ã®çµŒé¨“æ•°: ${this.memory.length}/${this.maxMemory}`);
            }

            async trainAfterGame() {
                if (this.memory.length < this.batchSize || !this.isTraining) {
                    console.log(`â¸ï¸ å­¦ç¿’ã‚¹ã‚­ãƒƒãƒ—: çµŒé¨“æ•°${this.memory.length} < å¿…è¦æ•°${this.batchSize}`);
                    return;
                }

                try {
                    this.showStatus('training', 'å­¦ç¿’å®Ÿè¡Œä¸­...');
                    this.trainingCount++;
                    
                    console.log(`ğŸ§  å­¦ç¿’é–‹å§‹ ${this.trainingCount}å›ç›®`);
                    
                    const batch = this.sampleBatch();
                    const states = batch.map(exp => exp.state);
                    const targets = this.calculateTargets(batch);

                    const statesTensor = tf.tensor2d(states);
                    const targetsTensor = tf.tensor2d(targets);

                    const history = await this.model.fit(statesTensor, targetsTensor, {
                        epochs: 2,
                        verbose: 0,
                        batchSize: this.batchSize
                    });

                    const loss = history.history.loss[history.history.loss.length - 1];
                    this.lossHistory.push(loss);
                    
                    console.log(`ğŸ“ˆ å­¦ç¿’å®Œäº†! Loss: ${loss.toFixed(4)}, Epsilon: ${(this.epsilon*100).toFixed(1)}%`);

                    statesTensor.dispose();
                    targetsTensor.dispose();

                    if (this.epsilon > this.epsilonMin) {
                        this.epsilon *= this.epsilonDecay;
                    }

                    if (this.gamesPlayed % 5 === 0) {
                        await this.saveModel();
                        this.saveStatistics();
                        console.log("ğŸ’¾ å®šæœŸä¿å­˜å®Œäº†");
                    }

                    this.showStatus('ready', 'å®‰å®šç‰ˆAIæº–å‚™å®Œäº†');
                    
                } catch (error) {
                    console.error("ğŸš¨ å­¦ç¿’ã‚¨ãƒ©ãƒ¼:", error);
                    this.showStatus('error', 'å­¦ç¿’å¤±æ•—');
                }
            }

            calculateTargets(batch) {
                const targets = [];
                
                for (const experience of batch) {
                    const target = new Array(180).fill(0);
                    
                    for (const action of experience.actions) {
                        const actionIndex = action[0] * 15 + action[1];
                        if (actionIndex < 180) {
                            target[actionIndex] = experience.reward;
                        }
                    }
                    
                    targets.push(target);
                }
                
                return targets;
            }

            sampleBatch() {
                const batch = [];
                for (let i = 0; i < Math.min(this.batchSize, this.memory.length); i++) {
                    const randomIndex = Math.floor(Math.random() * this.memory.length);
                    batch.push(this.memory[randomIndex]);
                }
                return batch;
            }

            async selectAction(gameState, currentPlayer, validMoves) {
                if (!this.isInitialized || !this.model || validMoves.length === 0) {
                    return this.fallbackAction(validMoves);
                }

                try {
                    this.showThinking("AIæˆ¦ç•¥åˆ†æä¸­...");

                    if (this.isTraining && Math.random() < this.epsilon) {
                        this.hideThinking();
                        const randomMove = this.fallbackAction(validMoves);
                        console.log(`ğŸ² æ¢ç´¢è¡Œå‹•: (${randomMove[0]}, ${randomMove[1]}) Îµ=${(this.epsilon*100).toFixed(1)}%`);
                        return randomMove;
                    }

                    const stateVector = this.encodeState(gameState, currentPlayer);
                    const stateTensor = tf.tensor2d([stateVector]);
                    const qValues = await this.model.predict(stateTensor);
                    const qArray = await qValues.data();

                    let bestMove = null;
                    let bestQ = -Infinity;

                    for (const move of validMoves) {
                        const actionIndex = move[0] * 15 + move[1];
                        if (actionIndex < qArray.length && qArray[actionIndex] > bestQ) {
                            bestQ = qArray[actionIndex];
                            bestMove = move;
                        }
                    }

                    stateTensor.dispose();
                    qValues.dispose();

                    this.hideThinking();
                    
                    if (bestMove) {
                        console.log(`ğŸ§  å­¦ç¿’è¡Œå‹•: (${bestMove[0]}, ${bestMove[1]}) Qå€¤=${bestQ.toFixed(3)}`);
                    }
                    
                    return bestMove || this.fallbackAction(validMoves);

                } catch (error) {
                    console.error("æ€è€ƒã‚¨ãƒ©ãƒ¼:", error);
                    this.hideThinking();
                    return this.fallbackAction(validMoves);
                }
            }

            encodeState(gameState, currentPlayer) {
                const vector = new Array(180).fill(0);
                let index = 0;

                for (let row = 0; row < 12; row++) {
                    for (let col = 0; col < 15; col++) {
                        const cell = gameState.grid[row] ? gameState.grid[row][col] || 0 : 0;
                        vector[index++] = cell === currentPlayer ? 1 : (cell === 0 ? 0 : -1);
                    }
                }

                return vector;
            }

            fallbackAction(validMoves) {
                if (validMoves.length === 0) return null;
                return validMoves[Math.floor(Math.random() * validMoves.length)];
            }

            updateUI() {
                try {
                    // å®‰å…¨ãªDOMæ“ä½œ
                    const elements = {
                        gamesCount: document.getElementById('gamesCount'),
                        winRate: document.getElementById('winRate'),
                        explorationRate: document.getElementById('explorationRate'),
                        learningStage: document.getElementById('learningStage'),
                        latestLoss: document.getElementById('latestLoss'),
                        avgReward: document.getElementById('avgReward'),
                        evolutionTrend: document.getElementById('evolutionTrend'),
                        memoryCount: document.getElementById('memoryCount')
                    };
                    
                    if (elements.gamesCount) {
                        elements.gamesCount.textContent = this.gamesPlayed;
                    }
                    
                    if (elements.winRate) {
                        elements.winRate.textContent = (this.winRate * 100).toFixed(1) + '%';
                    }
                    
                    if (elements.explorationRate) {
                        elements.explorationRate.textContent = (this.epsilon * 100).toFixed(1) + '%';
                    }
                    
                    // æˆé•·æ®µéš
                    if (elements.learningStage) {
                        let stage = 'èƒå…';
                        let stageColor = '#ef4444';
                        if (this.gamesPlayed > 3) { stage = 'å¹¼å…'; stageColor = '#f59e0b'; }
                        if (this.gamesPlayed > 10) { stage = 'å­¦ç¿’æœŸ'; stageColor = '#10b981'; }
                        if (this.gamesPlayed > 25) { stage = 'æˆé•·æœŸ'; stageColor = '#3b82f6'; }
                        if (this.gamesPlayed > 50) { stage = 'ç†Ÿç·´æœŸ'; stageColor = '#8b5cf6'; }
                        if (this.gamesPlayed > 100) { stage = 'ã‚¨ã‚­ã‚¹ãƒ‘ãƒ¼ãƒˆ'; stageColor = '#ec4899'; }
                        
                        elements.learningStage.textContent = stage;
                        elements.learningStage.style.color = stageColor;
                    }
                    
                    // å­¦ç¿’èª¤å·®
                    if (elements.latestLoss && this.lossHistory.length > 0) {
                        const latestLoss = this.lossHistory[this.lossHistory.length - 1];
                        elements.latestLoss.textContent = latestLoss.toFixed(4);
                    }
                    
                    // å¹³å‡å ±é…¬
                    if (elements.avgReward && this.memory.length > 0) {
                        const recentRewards = this.memory.slice(-10).map(exp => exp.reward);
                        const avgReward = recentRewards.reduce((a, b) => a + b, 0) / recentRewards.length;
                        elements.avgReward.textContent = avgReward.toFixed(3);
                    }

                    // é€²åŒ–å‚¾å‘
                    this.updateEvolutionTrend(elements.evolutionTrend);
                    
                    // ãƒ¡ãƒ¢ãƒªæ•°
                    if (elements.memoryCount) {
                        elements.memoryCount.textContent = this.memory.length;
                    }
                    
                } catch (error) {
                    console.error("UIæ›´æ–°ã‚¨ãƒ©ãƒ¼:", error);
                    // UIæ›´æ–°ã‚¨ãƒ©ãƒ¼ã§ã‚‚ç¶šè¡Œ
                }
            }

            updateEvolutionTrend(trendElement) {
                if (!trendElement || this.winRateHistory.length < 5) return;
                
                try {
                    const recent = this.winRateHistory.slice(-5);
                    const older = this.winRateHistory.slice(-10, -5);
                    
                    if (older.length === 0) return;
                    
                    const recentAvg = recent.reduce((a, b) => a + b, 0) / recent.length;
                    const olderAvg = older.reduce((a, b) => a + b, 0) / older.length;
                    
                    const diff = recentAvg - olderAvg;
                    let trendText = 'â†’';
                    let trendColor = '#6b7280';
                    
                    if (diff > 0.2) {
                        trendText = 'ğŸš€ çˆ†æˆé•·';
                        trendColor = '#10b981';
                    } else if (diff > 0.1) {
                        trendText = 'ğŸ“ˆ æ€¥æˆé•·';
                        trendColor = '#10b981';
                    } else if (diff > 0.05) {
                        trendText = 'â†—ï¸ æˆé•·ä¸­';
                        trendColor = '#3b82f6';
                    } else if (diff < -0.1) {
                        trendText = 'â†˜ï¸ èª¿æ•´æœŸ';
                        trendColor = '#f59e0b';
                    } else {
                        trendText = 'â†’ å®‰å®šæœŸ';
                        trendColor = '#8b5cf6';
                    }
                    
                    trendElement.textContent = trendText;
                    trendElement.style.color = trendColor;
                } catch (error) {
                    console.error("é€²åŒ–å‚¾å‘æ›´æ–°ã‚¨ãƒ©ãƒ¼:", error);
                }
            }

            showStatus(type, message) {
                try {
                    const indicator = document.getElementById('mlIndicator');
                    const text = document.getElementById('mlStatusText');
                    
                    if (indicator) indicator.className = `ml-indicator ${type}`;
                    if (text) text.textContent = message;
                } catch (error) {
                    console.error("ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¡¨ç¤ºã‚¨ãƒ©ãƒ¼:", error);
                }
            }

            updateProgress(percent) {
                try {
                    const progress = document.getElementById('mlProgress');
                    if (progress) progress.style.width = percent + '%';
                } catch (error) {
                    console.error("ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹æ›´æ–°ã‚¨ãƒ©ãƒ¼:", error);
                }
            }

            showThinking(message) {
                try {
                    const modal = document.getElementById('aiThinkingModal');
                    const text = document.getElementById('thinkingText');
                    
                    if (text) text.textContent = message;
                    if (modal) modal.style.display = 'block';
                } catch (error) {
                    console.error("æ€è€ƒè¡¨ç¤ºã‚¨ãƒ©ãƒ¼:", error);
                }
            }

            hideThinking() {
                try {
                    const modal = document.getElementById('aiThinkingModal');
                    if (modal) modal.style.display = 'none';
                } catch (error) {
                    console.error("æ€è€ƒéè¡¨ç¤ºã‚¨ãƒ©ãƒ¼:", error);
                }
            }

            toggleTraining() {
                this.isTraining = !this.isTraining;
                console.log(`ğŸ“ å­¦ç¿’ãƒ¢ãƒ¼ãƒ‰: ${this.isTraining ? 'ON' : 'OFF'}`);
            }

            reset() {
                try {
                    this.memory = [];
                    this.gameExperiences = [];
                    this.gamesPlayed = 0;
                    this.wins = 0;
                    this.winRate = 0;
                    this.epsilon = 1.0;
                    this.lossHistory = [];
                    this.winRateHistory = [];
                    this.trainingCount = 0;
                    
                    if (this.model) {
                        this.model.dispose();
                    }
                    this.createStableModel();
                    
                    localStorage.removeItem(this.statsKey);
                    this.saveModel();
                    this.saveStatistics();
                    
                    this.updateUI();
                    console.log("ğŸ”„ å®‰å®šç‰ˆAIå®Œå…¨ãƒªã‚»ãƒƒãƒˆå®Œäº†");
                } catch (error) {
                    console.error("ãƒªã‚»ãƒƒãƒˆã‚¨ãƒ©ãƒ¼:", error);
                }
            }
        }

        // â˜…â˜…â˜… å…¨ã¦ã®é–¢æ•°å®šç¾©ï¼ˆfunctionå®£è¨€ã§hoistingåˆ©ç”¨ï¼‰ â˜…â˜…â˜…
        
        // ã‚°ãƒªãƒƒãƒ‰åˆæœŸåŒ–
        function initGrid() {
            game.grid = [];
            for (var row = 0; row < GRID_HEIGHT; row++) {
                game.grid[row] = [];
                for (var col = 0; col < GRID_WIDTH; col++) {
                    game.grid[row][col] = 0;
                }
            }
        }
        function resetGameState() {
        clearInterval(game.timer);
        clearWinningCells();
        game.grid = [];
        game.currentPlayer = 1;
        game.firstPlayer = 1;
        game.aiPlayer = null;
        game.remainingBlocks = 1;
        game.timeLeft = 30;
        game.gameActive = false;
        game.timer = null;
        game.animating = false;
        game.winningCells = [];
        game.showingWin = false;
        game.turnCount = 0;
        game.isAI = false;
        game.aiThinking = false;
    }


        // å‹åˆ©ãƒ©ã‚¤ãƒ³ã‚’è¡¨ç¤ºã™ã‚‹é–¢æ•°
        function showWinningCells() {
            console.log("å‹åˆ©ãƒ©ã‚¤ãƒ³è¡¨ç¤º:", game.winningCells);
        }

        // å‹åˆ©ãƒ©ã‚¤ãƒ³ã‚’ã‚¯ãƒªã‚¢ã™ã‚‹é–¢æ•°
        function clearWinningCells() {
            game.winningCells = [];
            console.log("å‹åˆ©ãƒ©ã‚¤ãƒ³ã‚¯ãƒªã‚¢");
        }

        // ã‚²ãƒ¼ãƒ é–‹å§‹é–¢æ•°
        function startGame(isVsAI) {
            GRID_WIDTH = 15;
            GRID_HEIGHT = 12;
            if (typeof isVsAI === 'undefined') {
                isVsAI = false;
            }
            
            var levelSelect = document.getElementById('aiLevelSelect');
            aiLevel = levelSelect ? parseInt(levelSelect.value) : 1;

            initGrid();
            game.firstPlayer = Math.random() > 0.5 ? 1 : 2;
            game.currentPlayer = game.firstPlayer;
            
            if (isVsAI) {
                game.aiPlayer = Math.random() > 0.5 ? 1 : 2;
            } else {
                game.aiPlayer = null;
            }
            
            game.remainingBlocks = 1;
            game.timeLeft = 30;
            game.gameActive = true;
            game.animating = false;
            clearWinningCells();
            game.showingWin = false;
            game.turnCount = 0;
            game.isAI = isVsAI;
            game.aiThinking = false;

            var centerCol = Math.floor(GRID_WIDTH / 2);
            var groundRow = GRID_HEIGHT - 1;
            game.grid[groundRow][centerCol] = game.firstPlayer;

            console.log(`ã‚²ãƒ¼ãƒ é–‹å§‹ - å…ˆæ”»: ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼${game.firstPlayer}, AI: ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼${game.aiPlayer}`);

            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('gameScreen').style.display = 'block';
            document.getElementById('gameModal').style.display = 'none';

            createGrid();
            updateDisplay();
            startTimer();
            
            if (game.isAI && game.currentPlayer === game.aiPlayer) {
                   // æœ€åˆã®ã‚¿ãƒ¼ãƒ³è¡¨ç¤º
                setTimeout(() => {
                    showTurnChangeAnimation(game.currentPlayer);
                }, 300);
                console.log("AIãŒå…ˆæ”»ã§å‹•ä½œé–‹å§‹");
                setTimeout(cpuPlay, 1500);
            }
        }

        // ã‚¿ã‚¤ãƒãƒ¼é–‹å§‹
        function startTimer() {
            clearInterval(game.timer);
            
            game.timer = setInterval(function() {
                game.timeLeft--;
                updateDisplay();
                
                if (game.timeLeft <= 0) {
                    clearInterval(game.timer);
                    var winner = game.currentPlayer === 1 ? 2 : 1;
                    showAlert(`ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼${game.currentPlayer}ã®ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆï¼`);
                    setTimeout(async function() {
                        await endGame(winner);
                    }, 2000);
                }
            }, 1000);
        }

        // ã‚¹ã‚¿ãƒ¼ãƒˆç”»é¢è¡¨ç¤º
        function showStart() {
            clearInterval(game.timer);
            clearWinningCells();
            game.aiThinking = false;
            
            document.getElementById('startScreen').style.display = 'block';
            document.getElementById('gameScreen').style.display = 'none';
            document.getElementById('gameModal').style.display = 'none';
        }

        // ã‚°ãƒªãƒƒãƒ‰ä½œæˆ
        function createGrid() {
            
            
            var gridElement = document.getElementById('gameGrid');
                if (!gridElement) {
                    console.error('gameGridè¦ç´ ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
                    return;
                }
                gridElement.innerHTML = '';
            updateGridTemplate();
            
            for (var row = 0; row < GRID_HEIGHT; row++) {
                for (var col = 0; col < GRID_WIDTH; col++) {
                    var cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    cell.onclick = function() {
                        var clickedRow = parseInt(this.dataset.row);
                        var clickedCol = parseInt(this.dataset.col);
                        placePiece(clickedRow, clickedCol);
                    };

                    if (row === GRID_HEIGHT - 1) {
                        cell.classList.add('ground');
                    }

                    gridElement.appendChild(cell);
                }
            }
        }

        // ç”»é¢è¡¨ç¤ºæ›´æ–°
        function updateDisplay() {
           // document.getElementById('player1').classList.toggle('active', game.currentPlayer === 1);
           // document.getElementById('player2').classList.toggle('active', game.currentPlayer === 2);
            
            
            
            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼è¡¨ç¤ºåæ›´æ–°
            if (game.isAI) {
                var player1Name = document.getElementById('player1Name');
                var player2Name = document.getElementById('player2Name');
                
                if (game.aiPlayer === 1) {
                    player1Name.textContent = `AI (Lv${aiLevel})`;
                    player2Name.textContent = 'ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼2';
                } else {
                    player1Name.textContent = 'ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼1';
                    player2Name.textContent = `AI (Lv${aiLevel})`;
                }
            } else {
                document.getElementById('player1Name').textContent = 'ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼1';
                document.getElementById('player2Name').textContent = 'ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼2';
            }
            
            // ç¾åœ¨ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼æ›´æ–°
            var player1Indicator = document.getElementById('player1Indicator');
            var player2Indicator = document.getElementById('player2Indicator');
            
            if (player1Indicator && player2Indicator) {
                player1Indicator.classList.toggle('active', game.currentPlayer === 1);
                player2Indicator.classList.toggle('active', game.currentPlayer === 2);
            }
            
            document.getElementById('remainingBlocks').textContent = game.remainingBlocks;
            var maxBlocks = game.turnCount === 0 ? 1 : BLOCKS_PER_TURN;
            document.getElementById('maxBlocks').textContent = maxBlocks;
            
            var minutes = Math.floor(game.timeLeft / 60);
            var seconds = game.timeLeft % 60;
            var timerElement = document.getElementById('timer');
            timerElement.textContent = minutes + ':' + seconds.toString().padStart(2, '0');
            timerElement.classList.toggle('warning', game.timeLeft <= 30);

            updateGrid();
        }

        // ã‚°ãƒªãƒƒãƒ‰è¡¨ç¤ºæ›´æ–°
function updateGrid() {
            var cells = document.querySelectorAll('.cell');
            var index = 0;
            
            for (var row = 0; row < GRID_HEIGHT; row++) {
                for (var col = 0; col < GRID_WIDTH; col++) {
                    var cell = cells[index];
                    if (!cell) continue;
                    
                    var value = game.grid[row][col];
                    
                    cell.className = 'cell';
                    if (row === GRID_HEIGHT - 1) {
                        cell.classList.add('ground');
                    }
                    
                    // ::beforeã‚’ä½¿ç”¨ã™ã‚‹ã®ã§textContentã¯ç©ºã«
                    cell.textContent = '';
                    
                    if (value === 1) {
                        cell.classList.add('red');
                    } else if (value === 2) {
                        cell.classList.add('blue');
                    }
                    
                    index++;
                }
            }
            
            // å‹åˆ©ãƒ©ã‚¤ãƒ³è¡¨ç¤º
            if (game.showingWin && game.winningCells.length > 0) {
                for (var w = 0; w < game.winningCells.length; w++) {
                    var r = game.winningCells[w][0];
                    var c = game.winningCells[w][1];
                    var idx = r * GRID_WIDTH + c;
                    if (cells[idx]) {
                        cells[idx].classList.add('winning');
                    }
                }
            }
            
            // ç¾åœ¨ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼è‰²æ›´æ–°
            var currentPlayerColor = document.getElementById('currentPlayerColor');
            if (currentPlayerColor) {
                currentPlayerColor.className = `player-color-large ${game.currentPlayer === 1 ? 'red' : 'blue'}`;
            }
        }

        // åœ°é¢é…ç½®ãƒã‚§ãƒƒã‚¯
        function isValidGroundPlacement(col) {
            var groundRow = GRID_HEIGHT - 1;
            var leftCol = col - 1;
            var rightCol = col + 1;
            
            if (leftCol >= 0 && game.grid[groundRow][leftCol] !== 0) {
                return true;
            }
            if (rightCol < GRID_WIDTH && game.grid[groundRow][rightCol] !== 0) {
                return true;
            }
            
            return false;
        }

        // é…ç½®å¯èƒ½ã‹ãƒã‚§ãƒƒã‚¯
        function isValidPlacement(row, col) {
            if (row < 0 || row >= GRID_HEIGHT || col < 0 || col >= GRID_WIDTH) {
                return false;
            }
            if (game.grid[row][col] !== 0) {
                return false;
            }
            if (row < GRID_HEIGHT - 1 && game.grid[row + 1][col] === 0) {
                return false;
            }
            if (row === GRID_HEIGHT - 1 && !isValidGroundPlacement(col)) {
                return false;
            }
            return true;
        }

        // æœ‰åŠ¹ãªæ‰‹ã‚’ã™ã¹ã¦å–å¾—
        function getAllValidMoves() {
            var validMoves = [];
            
            for (var row = 0; row < GRID_HEIGHT; row++) {
                for (var col = 0; col < GRID_WIDTH; col++) {
                    if (game.grid[row][col] !== 0) continue;
                    
                    var hasSupport = (row === GRID_HEIGHT - 1) || 
                                    (row + 1 < GRID_HEIGHT && game.grid[row + 1][col] !== 0);
                    
                    if (hasSupport) {
                        if (row === GRID_HEIGHT - 1) {
                            if (isValidGroundPlacement(col)) {
                                validMoves.push([row, col]);
                            }
                        } else {
                            validMoves.push([row, col]);
                        }
                    }
                }
            }
            
            return validMoves;
        }

        // ãƒ©ãƒ³ãƒ€ãƒ ãªæ‰‹ã‚’é¸æŠ
        function getRandomMove() {
            const validMoves = getAllValidMoves();
            if (validMoves.length === 0) return null;
            const randomIndex = Math.floor(Math.random() * validMoves.length);
            return validMoves[randomIndex];
        }

        // å‹åˆ©å¯èƒ½ãªæ‰‹ã‚’æ¢ã™
        function findWinningMove(player) {
            console.log(`å‹åˆ©æ‰‹æ¤œç´¢é–‹å§‹ - ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼${player}`);
            
            var originalWinningCells = game.winningCells.slice();
            
            for (var row = 0; row < GRID_HEIGHT; row++) {
                for (var col = 0; col < GRID_WIDTH; col++) {
                    if (game.grid[row][col] !== 0) continue;
                    if (!isValidPlacement(row, col)) continue;
                    
                    game.grid[row][col] = player;
                    var canWin = checkWin(row, col);
                    game.grid[row][col] = 0;
                    
                    if (canWin) {
                        console.log(`å‹åˆ©æ‰‹ç™ºè¦‹: (${row}, ${col}) - ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼${player}ãŒå‹åˆ©`);
                        game.winningCells = originalWinningCells;
                        return [row, col];
                    }
                }
            }
            
            game.winningCells = originalWinningCells;
            console.log("å‹åˆ©æ‰‹ãªã—");
            return null;
        }

        // è©¦åˆæ®µéšåˆ¤å®š
        function getGamePhase() {
            var totalBlocks = 0;
            for (var row = 0; row < GRID_HEIGHT; row++) {
                for (var col = 0; col < GRID_WIDTH; col++) {
                    if (game.grid[row][col] !== 0) {
                        totalBlocks++;
                    }
                }
            }
            
            if (totalBlocks < 15) {
                return 'early';
            } else if (totalBlocks < 30) {
                return 'middle';
            } else {
                return 'late';
            }
        }

        // ç¸¦2é€£ä½œæˆæˆ¦ç•¥
        function findVerticalDoubleMove(player) {
            console.log(`ç¸¦2é€£ä½œæˆæˆ¦ç•¥æ¤œç´¢é–‹å§‹ - ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼${player}`);
            
            var validMoves = getAllValidMoves();
            var bestMove = null;
            var bestScore = 0;
            
            for (var i = 0; i < validMoves.length; i++) {
                var move = validMoves[i];
                var row = move[0];
                var col = move[1];
                
                game.grid[row][col] = player;
                var verticalScore = evaluateVerticalDouble(row, col, player);
                game.grid[row][col] = 0;
                
                if (verticalScore > bestScore) {
                    bestScore = verticalScore;
                    bestMove = move;
                }
            }
            
            if (bestMove && bestScore > 50) {
                console.log(`ç¸¦2é€£ä½œæˆæ‰‹é¸æŠ: (${bestMove[0]}, ${bestMove[1]}) - ã‚¹ã‚³ã‚¢:${bestScore}`);
                return bestMove;
            }
            
            console.log("æœ‰åŠ¹ãªç¸¦2é€£ä½œæˆæ‰‹ãªã—");
            return null;
        }

        // ç¸¦2é€£åŠ¹æœè©•ä¾¡
        function evaluateVerticalDouble(row, col, player) {
            var score = 0;
            
            if (row < GRID_HEIGHT - 1 && game.grid[row + 1][col] === player) {
                score += 80;
                
                if (row < GRID_HEIGHT - 2 && game.grid[row + 2][col] === player) {
                    score += 120;
                }
                
                if (row > 0 && game.grid[row - 1][col] === 0) {
                    score += 60;
                }
            }
            
            if (row > 0 && game.grid[row - 1][col] === player) {
                score += 70;
                
                if (row > 1 && game.grid[row - 2][col] === player) {
                    score += 100;
                }
            }
            
            var centerCol = Math.floor(GRID_WIDTH / 2);
            var distanceFromCenter = Math.abs(col - centerCol);
            score += Math.max(0, 20 - distanceFromCenter * 2);
            
            return score;
        }

        // ç¸¦2é€£ + æœ¬å‘½æ”»æ’ƒæˆ¦ç•¥
        function findVerticalDoublePlusThreatMove(player) {
            var gamePhase = getGamePhase();
            
            if (gamePhase !== 'late') {
                console.log(`ç¸¦2é€£+æœ¬å‘½æ”»æ’ƒ: ${gamePhase}ã®ãŸã‚ã‚¹ã‚­ãƒƒãƒ—ï¼ˆ30å€‹ä»¥ä¸Šã§ç™ºå‹•ï¼‰`);
                return null;
            }
            
            console.log(`ç¸¦2é€£+æœ¬å‘½æ”»æ’ƒæ¤œç´¢é–‹å§‹ - ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼${player} (çµ‚ç›¤æˆ¦ç•¥)`);
            
            var verticalDoubles = [];
            for (var row = 0; row < GRID_HEIGHT - 1; row++) {
                for (var col = 0; col < GRID_WIDTH; col++) {
                    if (game.grid[row][col] === player && game.grid[row + 1][col] === player) {
                        if (row > 0 && game.grid[row - 1][col] === 0 && isValidPlacement(row - 1, col)) {
                            verticalDoubles.push({
                                extendPos: [row - 1, col],
                                baseRow: row + 1,
                                score: 90
                            });
                        }
                    }
                }
            }
            
            if (verticalDoubles.length === 0) {
                console.log("æ´»ç”¨å¯èƒ½ãªç¸¦2é€£ãªã—");
                return null;
            }
            
            console.log(`æ´»ç”¨å¯èƒ½ãªç¸¦2é€£: ${verticalDoubles.length}å€‹ç™ºè¦‹`);
            
            var validMoves = getAllValidMoves();
            var bestComboMove = null;
            var bestComboScore = 0;
            
            for (var i = 0; i < validMoves.length; i++) {
                var move = validMoves[i];
                var row = move[0];
                var col = move[1];
                
                game.grid[row][col] = player;
                
                var threats = findConsecutiveBlocks(player, 2);
                var mainThreatScore = 0;
                
                for (var t = 0; t < threats.length; t++) {
                    mainThreatScore += evaluateThreat(threats[t], player);
                }
                
                game.grid[row][col] = 0;
                
                if (mainThreatScore > 200) {
                    for (var v = 0; v < verticalDoubles.length; v++) {
                        var vDouble = verticalDoubles[v];
                        
                        if (row !== vDouble.extendPos[0] || col !== vDouble.extendPos[1]) {
                            var comboScore = mainThreatScore + vDouble.score + 150;
                            
                            if (comboScore > bestComboScore) {
                                bestComboScore = comboScore;
                                bestComboMove = move;
                            }
                        }
                    }
                }
            }
            
            if (bestComboMove && bestComboScore > 400) {
                console.log(`ç¸¦2é€£+æœ¬å‘½æ”»æ’ƒæ‰‹é¸æŠ: (${bestComboMove[0]}, ${bestComboMove[1]}) - ã‚³ãƒ³ãƒœã‚¹ã‚³ã‚¢:${bestComboScore}`);
                return bestComboMove;
            }
            
            console.log("æœ‰åŠ¹ãªç¸¦2é€£+æœ¬å‘½æ”»æ’ƒãªã—");
            return null;
        }

        // ç›¸æ‰‹ã®ç¸¦2é€£é˜»æ­¢
        function findVerticalDoubleBlock(player) {
            var opponent = player === 1 ? 2 : 1;
            var gamePhase = getGamePhase();
            
            if (gamePhase !== 'late') {
                console.log(`ç›¸æ‰‹ç¸¦2é€£é˜»æ­¢: ${gamePhase}ã®ãŸã‚ã‚¹ã‚­ãƒƒãƒ—ï¼ˆ30å€‹ä»¥ä¸Šã§ç™ºå‹•ï¼‰`);
                return null;
            }
            
            console.log(`ç›¸æ‰‹ç¸¦2é€£é˜»æ­¢æ¤œç´¢ - ç›¸æ‰‹ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼${opponent} (çµ‚ç›¤æˆ¦ç•¥)`);
            
            var dangerousVerticalDoubles = [];
            
            for (var row = 0; row < GRID_HEIGHT - 1; row++) {
                for (var col = 0; col < GRID_WIDTH; col++) {
                    if (game.grid[row][col] === opponent && game.grid[row + 1][col] === opponent) {
                        if (row > 0 && game.grid[row - 1][col] === 0 && isValidPlacement(row - 1, col)) {
                            var dangerLevel = 120;
                            
                            var centerCol = Math.floor(GRID_WIDTH / 2);
                            var distanceFromCenter = Math.abs(col - centerCol);
                            dangerLevel += Math.max(0, 20 - distanceFromCenter * 2);
                            
                            dangerousVerticalDoubles.push({
                                blockPos: [row - 1, col],
                                danger: dangerLevel
                            });
                        }
                    }
                }
            }
            
            if (dangerousVerticalDoubles.length > 0) {
                dangerousVerticalDoubles.sort(function(a, b) { return b.danger - a.danger; });
                var mostDangerous = dangerousVerticalDoubles[0];
                
                console.log(`å±é™ºãªç›¸æ‰‹ç¸¦2é€£é˜»æ­¢: (${mostDangerous.blockPos[0]}, ${mostDangerous.blockPos[1]}) - å±é™ºåº¦:${mostDangerous.danger}`);
                return mostDangerous.blockPos;
            }
            
            console.log("é˜»æ­¢ã™ã¹ãç›¸æ‰‹ç¸¦2é€£ãªã—");
            return null;
        }

        // ç›¸æ‰‹ã®å‹åˆ©ã‚’é˜»æ­¢ã™ã‚‹æ‰‹ã‚’æ¢ã™
        function findBlockingMove(player) {
            var opponent = player === 1 ? 2 : 1;
            console.log(`é˜»æ­¢æ‰‹æ¤œç´¢é–‹å§‹ - ç›¸æ‰‹ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼${opponent}ã®å‹åˆ©ã‚’é˜»æ­¢`);
            
            var originalWinningCells = game.winningCells.slice();
            
            for (var row = 0; row < GRID_HEIGHT; row++) {
                for (var col = 0; col < GRID_WIDTH; col++) {
                    if (game.grid[row][col] !== 0) continue;
                    if (!isValidPlacement(row, col)) continue;
                    
                    game.grid[row][col] = opponent;
                    var opponentWins = checkWin(row, col);
                    game.grid[row][col] = 0;
                    
                    if (opponentWins) {
                        console.log(`é˜»æ­¢æ‰‹ç™ºè¦‹: (${row}, ${col}) - ç›¸æ‰‹ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼${opponent}ã®å‹åˆ©ã‚’é˜»æ­¢`);
                        game.winningCells = originalWinningCells;
                        return [row, col];
                    }
                }
            }
            
            game.winningCells = originalWinningCells;
            console.log("é˜»æ­¢æ‰‹ãªã—");
            return null;
        }

        // 3é€£è„…å¨ã‚’æ¤œå‡ºãƒ»é˜»æ­¢ã™ã‚‹å°‚ç”¨é–¢æ•°
        function findThreeInARowThreat(player) {
            var opponent = player === 1 ? 2 : 1;
            console.log(`3é€£è„…å¨æ¤œç´¢é–‹å§‹ - ç›¸æ‰‹ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼${opponent}`);
            
            var originalWinningCells = game.winningCells.slice();
            var threats = [];

            var consecutiveBlocks = findConsecutiveBlocks(opponent, 3);
            
            for (var i = 0; i < consecutiveBlocks.length; i++) {
                var blockInfo = consecutiveBlocks[i];
                var line = blockInfo.line;
                var direction = blockInfo.direction;
                var extendable = blockInfo.extendable;
                var isGround = blockInfo.isGround;

                var threatLevel = 0;
                var blockPositions = [];

                if (line.length === 3) {
                    if (direction === 1) {
                        console.log(`å±é™ºãªç¸¦3é€£æ¤œå‡º:`, line);
                        threatLevel = 900;
                        
                        for (var j = 0; j < extendable.length; j++) {
                            var pos = extendable[j];
                            if (pos[0] < line[0][0]) {
                                if (isValidPlacement(pos[0], pos[1])) {
                                    blockPositions.push(pos);
                                }
                            }
                        }
                    } else if (direction === 0 && isGround) {
                        console.log(`å±é™ºãªåœ°é¢æ¨ª3é€£æ¤œå‡º:`, line);
                        threatLevel = 950;
                        
                        for (var j = 0; j < extendable.length; j++) {
                            var pos = extendable[j];
                            if (isValidPlacement(pos[0], pos[1])) {
                                blockPositions.push(pos);
                            }
                        }
                    } else if (direction === 0) {
                        console.log(`æ¨ª3é€£æ¤œå‡º:`, line);
                        threatLevel = 700;
                        
                        for (var j = 0; j < extendable.length; j++) {
                            var pos = extendable[j];
                            if (isValidPlacement(pos[0], pos[1])) {
                                blockPositions.push(pos);
                            }
                        }
                    } else {
                        console.log(`æ–œã‚3é€£æ¤œå‡º:`, line);
                        threatLevel = 600;
                        
                        for (var j = 0; j < extendable.length; j++) {
                            var pos = extendable[j];
                            if (isValidPlacement(pos[0], pos[1])) {
                                blockPositions.push(pos);
                            }
                        }
                    }
                } else if (line.length === 4) {
                    console.log(`æ¥µã‚ã¦å±é™ºãª4é€£æ¤œå‡º:`, line);
                    threatLevel = 1000;
                    
                    for (var j = 0; j < extendable.length; j++) {
                        var pos = extendable[j];
                        if (isValidPlacement(pos[0], pos[1])) {
                            blockPositions.push(pos);
                        }
                    }
                }

                if (blockPositions.length > 0) {
                    threats.push({
                        level: threatLevel,
                        positions: blockPositions,
                        type: direction === 1 ? 'ç¸¦' : (direction === 0 ? (isGround ? 'åœ°é¢æ¨ª' : 'æ¨ª') : 'æ–œã‚'),
                        length: line.length
                    });
                }
            }

            game.winningCells = originalWinningCells;

            if (threats.length > 0) {
                threats.sort(function(a, b) { return b.level - a.level; });
                
                var topThreat = threats[0];
                console.log(`æœ€å„ªå…ˆè„…å¨: ${topThreat.type}${topThreat.length}é€£ (è„…å¨ãƒ¬ãƒ™ãƒ«:${topThreat.level})`);
                
                var blockPos = topThreat.positions[0];
                console.log(`3é€£è„…å¨é˜»æ­¢æ‰‹: (${blockPos[0]}, ${blockPos[1]})`);
                return blockPos;
            }

            console.log("3é€£è„…å¨ãªã—");
            return null;
        }

        // ä¸­å¤®ä»˜è¿‘ã®ä¾¡å€¤ã®é«˜ã„æ‰‹ã‚’æ¢ã™
        function findCenterMove() {
            console.log("ä¸­å¤®åˆ¶åœ§æ‰‹æ¤œç´¢é–‹å§‹");
            
            var centerCol = Math.floor(GRID_WIDTH / 2);
            var validMoves = getAllValidMoves();
            
            if (validMoves.length === 0) {
                console.log("ä¸­å¤®åˆ¶åœ§æ‰‹ãªã— - æœ‰åŠ¹æ‰‹ãŒ0å€‹");
                return null;
            }
            
            validMoves.sort(function(a, b) {
                var distA = Math.abs(a[1] - centerCol);
                var distB = Math.abs(b[1] - centerCol);
                return distA - distB;
            });
            
            console.log(`ä¸­å¤®åˆ¶åœ§æ‰‹é¸æŠ: (${validMoves[0][0]}, ${validMoves[0][1]}) - ä¸­å¤®ã‹ã‚‰ã®è·é›¢: ${Math.abs(validMoves[0][1] - centerCol)}`);
            return validMoves[0];
        }

        // 2æ‰‹å‹åˆ©ã®å¯èƒ½æ€§ã‚’æ¢ã™
        function findTwoMoveWin(player) {
            console.log(`2æ‰‹å‹åˆ©æ¤œç´¢é–‹å§‹ - ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼${player}`);
            
            var originalWinningCells = game.winningCells.slice();
            var validMoves = getAllValidMoves();
            
            for (var i = 0; i < validMoves.length; i++) {
                var move = validMoves[i];
                var row = move[0];
                var col = move[1];
                
                game.grid[row][col] = player;
                
                var hasWinningFollow = false;
                for (var row2 = 0; row2 < GRID_HEIGHT; row2++) {
                    for (var col2 = 0; col2 < GRID_WIDTH; col2++) {
                        if (game.grid[row2][col2] !== 0) continue;
                        if (!isValidPlacement(row2, col2)) continue;
                        
                        game.grid[row2][col2] = player;
                        var canWin = checkWin(row2, col2);
                        game.grid[row2][col2] = 0;
                        
                        if (canWin) {
                            hasWinningFollow = true;
                            break;
                        }
                    }
                    if (hasWinningFollow) break;
                }
                
                game.grid[row][col] = 0;
                
                if (hasWinningFollow) {
                    console.log(`2æ‰‹å‹åˆ©ã®èµ·ç‚¹ç™ºè¦‹: (${row}, ${col}) - ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼${player}`);
                    game.winningCells = originalWinningCells;
                    return [row, col];
                }
            }
            
            game.winningCells = originalWinningCells;
            console.log("2æ‰‹å‹åˆ©ãªã—");
            return null;
        }

        // é€£ç¶šãƒ–ãƒ­ãƒƒã‚¯æ¤œå‡º
        function findConsecutiveBlocks(player, length) {
            var results = [];
            var directions = [
                [0, 1],  // æ¨ª
                [1, 0],  // ç¸¦
                [1, 1],  // æ–œã‚å³ä¸‹
                [1, -1]  // æ–œã‚å·¦ä¸‹
            ];

            for (var row = 0; row < GRID_HEIGHT; row++) {
                for (var col = 0; col < GRID_WIDTH; col++) {
                    if (game.grid[row][col] !== player) continue;

                    for (var d = 0; d < directions.length; d++) {
                        var dr = directions[d][0];
                        var dc = directions[d][1];
                        var line = [[row, col]];
                        
                        for (var i = 1; i < WIN_COUNT; i++) {
                            var r = row + dr * i;
                            var c = col + dc * i;
                            if (r >= 0 && r < GRID_HEIGHT && c >= 0 && c < GRID_WIDTH && 
                                game.grid[r][c] === player) {
                                line.push([r, c]);
                            } else {
                                break;
                            }
                        }

                        if (line.length >= length) {
                            var extendable = [];
                            
                            var frontR = row - dr;
                            var frontC = col - dc;
                            if (frontR >= 0 && frontR < GRID_HEIGHT && frontC >= 0 && frontC < GRID_WIDTH && 
                                game.grid[frontR][frontC] === 0) {
                                extendable.push([frontR, frontC]);
                            }
                            
                            var backR = row + dr * line.length;
                            var backC = col + dc * line.length;
                            if (backR >= 0 && backR < GRID_HEIGHT && backC >= 0 && backC < GRID_WIDTH && 
                                game.grid[backR][backC] === 0) {
                                extendable.push([backR, backC]);
                            }

                            results.push({
                                line: line,
                                direction: d,
                                extendable: extendable,
                                isGround: row === GRID_HEIGHT - 1 || (row + dr * (line.length - 1)) === GRID_HEIGHT - 1
                            });
                        }
                    }
                }
            }

            return results;
        }

        // è„…å¨è©•ä¾¡
        function evaluateThreat(consecutiveInfo, player) {
            var length = consecutiveInfo.line.length;
            var extendable = consecutiveInfo.extendable;
            var isGround = consecutiveInfo.isGround;
            var direction = consecutiveInfo.direction;

            var score = 0;

            if (length === 4) {
                score = 1000;
                if (extendable.length >= 1) {
                    score += 500;
                }
            } else if (length === 3) {
                if (direction === 1) {
                    score = 800;
                } else if (direction === 0 && isGround) {
                    score = 850;
                } else if (direction === 0) {
                    if (extendable.length >= 2) {
                        score = 700;
                    } else if (extendable.length === 1) {
                        score = 500;
                    }
                } else {
                    if (extendable.length >= 2) {
                        score = 600;
                    } else if (extendable.length === 1) {
                        score = 400;
                    }
                }
            } else if (length === 2) {
                score = length * 10;
            }

            return score;
        }

        // é˜²å¾¡å¿…è¦æ•°è¨ˆç®—
        function calculateDefenseRequired(consecutiveInfo, player) {
            var length = consecutiveInfo.line.length;
            var extendable = consecutiveInfo.extendable;
            var direction = consecutiveInfo.direction;
            var isGround = consecutiveInfo.isGround;

            if (length === 4) {
                var requiredBlocks = 0;
                for (var i = 0; i < extendable.length; i++) {
                    var pos = extendable[i];
                    if (isValidPlacement(pos[0], pos[1])) {
                        requiredBlocks++;
                    }
                }
                return Math.min(requiredBlocks, 2);
            } else if (length === 3) {
                if (direction === 1) {
                    return 1;
                } else if (direction === 0 && isGround) {
                    return 2;
                } else {
                    var validExtendable = 0;
                    for (var i = 0; i < extendable.length; i++) {
                        var pos = extendable[i];
                        if (isValidPlacement(pos[0], pos[1])) {
                            validExtendable++;
                        }
                    }
                    return Math.min(validExtendable, 2);
                }
            }

            return 1;
        }

        // è¤‡æ•°è„…å¨ä½œæˆæ‰‹ã‚’æ¢ã™
        function findMultipleThreatMove(player) {
            console.log(`è¤‡æ•°è„…å¨æ¤œç´¢é–‹å§‹ - ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼${player}`);
            
            var originalWinningCells = game.winningCells.slice();
            var validMoves = getAllValidMoves();
            var bestMove = null;
            var maxThreats = 0;

            for (var i = 0; i < validMoves.length; i++) {
                var move = validMoves[i];
                var row = move[0];
                var col = move[1];

                game.grid[row][col] = player;

                var threats = findConsecutiveBlocks(player, 3);
                var totalThreatScore = 0;
                var defenseRequired = 0;

                for (var t = 0; t < threats.length; t++) {
                    var threat = threats[t];
                    totalThreatScore += evaluateThreat(threat, player);
                    defenseRequired += calculateDefenseRequired(threat, player);
                }

                if (threats.length >= 2 && defenseRequired >= 3) {
                    console.log(`è¤‡æ•°è„…å¨ç™ºè¦‹: (${row}, ${col}) - è„…å¨æ•°:${threats.length}, é˜²å¾¡å¿…è¦æ•°:${defenseRequired}`);
                    
                    if (defenseRequired > maxThreats || (defenseRequired === maxThreats && totalThreatScore > 0)) {
                        maxThreats = defenseRequired;
                        bestMove = [row, col];
                    }
                }

                game.grid[row][col] = 0;
            }

            game.winningCells = originalWinningCells;
            
            if (bestMove) {
                console.log(`è¤‡æ•°è„…å¨æ‰‹é¸æŠ: (${bestMove[0]}, ${bestMove[1]}) - é˜²å¾¡å¿…è¦æ•°:${maxThreats}`);
            } else {
                console.log("è¤‡æ•°è„…å¨æ‰‹ãªã—");
            }
            
            return bestMove;
        }

        // é«˜è„…å¨æ‰‹ã‚’æ¢ã™
        function findHighThreatMove(player) {
            console.log(`é«˜è„…å¨æ‰‹æ¤œç´¢é–‹å§‹ - ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼${player}`);
            
            var originalWinningCells = game.winningCells.slice();
            var validMoves = getAllValidMoves();
            var bestMove = null;
            var maxScore = 0;

            for (var i = 0; i < validMoves.length; i++) {
                var move = validMoves[i];
                var row = move[0];
                var col = move[1];

                game.grid[row][col] = player;

                var threats = findConsecutiveBlocks(player, 2);
                var totalScore = 0;

                for (var t = 0; t < threats.length; t++) {
                    totalScore += evaluateThreat(threats[t], player);
                }

                if (totalScore > maxScore) {
                    maxScore = totalScore;
                    bestMove = [row, col];
                }

                game.grid[row][col] = 0;
            }

            game.winningCells = originalWinningCells;
            
            if (bestMove && maxScore > 100) {
                console.log(`é«˜è„…å¨æ‰‹é¸æŠ: (${bestMove[0]}, ${bestMove[1]}) - ã‚¹ã‚³ã‚¢:${maxScore}`);
                return bestMove;
            }
            
            console.log("æœ‰åŠ¹ãªé«˜è„…å¨æ‰‹ãªã—");
            return null;
        }

        // ç›¸æ‰‹ã®è¤‡æ•°è„…å¨ã‚’é˜»æ­¢
        function findMultipleThreatBlock(player) {
            var opponent = player === 1 ? 2 : 1;
            console.log(`ç›¸æ‰‹è¤‡æ•°è„…å¨é˜»æ­¢æ¤œç´¢ - ç›¸æ‰‹ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼${opponent}`);
            
            var opponentThreats = findConsecutiveBlocks(opponent, 3);
            if (opponentThreats.length < 2) {
                return null;
            }

            var totalDefenseRequired = 0;
            for (var i = 0; i < opponentThreats.length; i++) {
                totalDefenseRequired += calculateDefenseRequired(opponentThreats[i], opponent);
            }

            if (totalDefenseRequired >= 3) {
                console.log(`ç›¸æ‰‹ã®è¤‡æ•°è„…å¨æ¤œå‡º - é˜²å¾¡å¿…è¦æ•°:${totalDefenseRequired}`);
                
                var mostDangerous = null;
                var maxScore = 0;
                
                for (var i = 0; i < opponentThreats.length; i++) {
                    var threat = opponentThreats[i];
                    var score = evaluateThreat(threat, opponent);
                    if (score > maxScore) {
                        maxScore = score;
                        mostDangerous = threat;
                    }
                }

                if (mostDangerous && mostDangerous.extendable.length > 0) {
                    var blockPos = mostDangerous.extendable[0];
                    if (isValidPlacement(blockPos[0], blockPos[1])) {
                        console.log(`è¤‡æ•°è„…å¨é˜»æ­¢æ‰‹: (${blockPos[0]}, ${blockPos[1]})`);
                        return blockPos;
                    }
                }
            }

            return null;
        }

        // ãƒ–ãƒ­ãƒƒã‚¯é…ç½®å‡¦ç†
        function placePiece(row, col, isAIMove) {
            try {
                if (row < 0 || row >= GRID_HEIGHT || col < 0 || col >= GRID_WIDTH) {
                    return;
                }
                
                if (!game.gameActive || game.animating || game.remainingBlocks <= 0) {
                    return;
                }
                
                if (game.isAI && game.currentPlayer === game.aiPlayer && !isAIMove) {
                    return;
                }
                
                if (game.grid[row][col] !== 0) {
                    if (!isAIMove) {
                        showAlert("ãã®ãƒã‚¹ã«ã¯æ—¢ã«ãƒ–ãƒ­ãƒƒã‚¯ãŒã‚ã‚Šã¾ã™ï¼");
                    }
                    return;
                }
                
                if (row < GRID_HEIGHT - 1 && game.grid[row + 1][col] === 0) {
                    if (!isAIMove) {
                        showAlert("ã“ã®ä½ç½®ã«ã¯ä¸‹ã«æ”¯ãˆãŒã‚ã‚Šã¾ã›ã‚“ï¼");
                    }
                    return;
                }
                
                if (row === GRID_HEIGHT - 1 && !isValidGroundPlacement(col)) {
                    if (!isAIMove) {
                        showAlert("åœ°é¢ã«ç½®ãã«ã¯éš£æ¥ãƒ–ãƒ­ãƒƒã‚¯ãŒå¿…è¦ã§ã™ï¼");
                    }
                    return;
                }
                
                game.animating = true;
                
                setTimeout(function () {
                    game.grid[row][col] = game.currentPlayer;
                    game.remainingBlocks--;
                    
                    console.log(`ãƒ–ãƒ­ãƒƒã‚¯é…ç½®å®Œäº† - ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼${game.currentPlayer}, æ®‹ã‚Š${game.remainingBlocks}å€‹`);
                    
                    if (checkWin(row, col)) {
                        game.showingWin = true;
                        console.log("å‹åˆ©ç¢ºå®šï¼å‹åˆ©ãƒ©ã‚¤ãƒ³è¡¨ç¤ºé–‹å§‹");
                        
                        showWinningCells();
                        updateGrid();
                        
                        setTimeout(async function() {
                            await endGame(game.currentPlayer);
                        }, 3000);
                        return;
                    }
                    
                    if (game.remainingBlocks <= 0) {
                        setTimeout(function () {
                            clearInterval(game.timer);
                            
                            game.currentPlayer = game.currentPlayer === 1 ? 2 : 1;
                            game.turnCount++;
                            
                            game.remainingBlocks = game.turnCount === 1 ? BLOCKS_PER_TURN : BLOCKS_PER_TURN;
                            
                            if (game.turnCount === 0) {
                                game.timeLeft = 30;
                            } else if (game.turnCount === 1) {
                                game.timeLeft = 45;
                            } else {
                                game.timeLeft = 60;
                            }
                            
                            console.log(`ã‚¿ãƒ¼ãƒ³äº¤ä»£ - ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼${game.currentPlayer}, ã‚¿ãƒ¼ãƒ³${game.turnCount}`);
                            
                            // ã‚¿ãƒ¼ãƒ³äº¤ä»£ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³è¿½åŠ 
                            showTurnChangeAnimation(game.currentPlayer);
                            
                            startTimer();
                            updateDisplay();
                            
                            if (game.isAI && game.currentPlayer === game.aiPlayer) {
                                setTimeout(cpuPlay, 800);
                            }
                        }, 500);
                    }
                    
                    game.animating = false;
                    updateDisplay();
                    
                    checkAndExtendGrid();
                    
                }, 300);
                
            } catch (error) {
                console.error("ãƒ–ãƒ­ãƒƒã‚¯é…ç½®ã§ã‚¨ãƒ©ãƒ¼:", error);
                game.animating = false;
                showAlert("ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚");
            }
        }

        // ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰æ‹¡å¼µæ©Ÿèƒ½
        function checkAndExtendGrid() {
            var needsUpdate = false;

            for (var row = 0; row < GRID_HEIGHT; row++) {
                if (game.grid[row][0] !== 0) {
                    console.log("å·¦ç«¯æ‹¡å¼µå®Ÿè¡Œ");
                    extendGridLeft();
                    needsUpdate = true;
                    break;
                }
            }

            for (var row = 0; row < GRID_HEIGHT; row++) {
                if (game.grid[row][GRID_WIDTH - 1] !== 0) {
                    console.log("å³ç«¯æ‹¡å¼µå®Ÿè¡Œ");
                    extendGridRight();
                    needsUpdate = true;
                    break;
                }
            }

            for (var col = 0; col < GRID_WIDTH; col++) {
                if (game.grid[0][col] !== 0) {
                    console.log("ä¸Šç«¯æ‹¡å¼µå®Ÿè¡Œ");
                    extendGridTop();
                    needsUpdate = true;
                    break;
                }
            }

            if (needsUpdate) {
                createGrid();
                updateDisplay();
            }
        }

        function extendGridLeft() {
            for (var row = 0; row < GRID_HEIGHT; row++) {
                game.grid[row].unshift(0);
            }
            GRID_WIDTH++;
            console.log(`å·¦æ‹¡å¼µå®Œäº† - æ–°ã‚µã‚¤ã‚º: ${GRID_WIDTH}x${GRID_HEIGHT}`);
        }

        function extendGridRight() {
            for (var row = 0; row < GRID_HEIGHT; row++) {
                game.grid[row].push(0);
            }
            GRID_WIDTH++;
            console.log(`å³æ‹¡å¼µå®Œäº† - æ–°ã‚µã‚¤ã‚º: ${GRID_WIDTH}x${GRID_HEIGHT}`);
        }

        function extendGridTop() {
            var newRow = new Array(GRID_WIDTH).fill(0);
            game.grid.unshift(newRow);
            GRID_HEIGHT++;
            console.log(`ä¸Šæ‹¡å¼µå®Œäº† - æ–°ã‚µã‚¤ã‚º: ${GRID_WIDTH}x${GRID_HEIGHT}`);
        }

      function updateGridTemplate() {
            var gridElement = document.getElementById('gameGrid');
            if (gridElement) {
                var screenWidth = window.innerWidth;
                var cellSize;
                
                if (screenWidth <= 480) {
                    cellSize = '20px';  // å°ã•ã„ã‚¹ãƒãƒ›
                } else if (screenWidth <= 600) {
                    cellSize = '24px';  // ã‚¹ãƒãƒ›
                } else if (screenWidth <= 768) {
                    cellSize = '32px';  // ã‚¿ãƒ–ãƒ¬ãƒƒãƒˆ
                } else {
                    cellSize = '56px';  // PCï¼ˆæ‹¡å¤§ï¼‰
                }
                
                gridElement.style.gridTemplateColumns = `repeat(${GRID_WIDTH}, ${cellSize})`;
                console.log(`ã‚°ãƒªãƒƒãƒ‰æ›´æ–°: ${GRID_WIDTH}åˆ— Ã— ${cellSize} (ç”»é¢å¹…: ${screenWidth}px)`);
                
                // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ä½ç½®ã‚’ä¸­å¤®ã«èª¿æ•´ï¼ˆæ–°ã—ã„åˆ—ãŒè¿½åŠ ã•ã‚ŒãŸæ™‚ï¼‰
                var container = gridElement.closest('.grid-container');
                if (container && GRID_WIDTH > 15) {
                    setTimeout(() => {
                        container.scrollLeft = (container.scrollWidth - container.clientWidth) / 2;
                    }, 100);
                }
            }
        }

        // ç”»é¢ãƒªã‚µã‚¤ã‚ºæ™‚ã®å¯¾å¿œã‚‚è¿½åŠ 
        window.addEventListener('resize', function() {
            if (document.getElementById('gameGrid')) {
                updateGridTemplate();
            }
        });

        async function cpuPlay() {
            if (!game.gameActive || game.currentPlayer !== game.aiPlayer || !game.isAI || game.showingWin) {
                console.log("AIå‹•ä½œåœæ­¢");
                return;
            }

            console.log(`AIå‹•ä½œé–‹å§‹ Lv${aiLevel} - é…ç½®äºˆå®šãƒ–ãƒ­ãƒƒã‚¯æ•°:`, game.remainingBlocks);
            
            game.aiThinking = true;

            // LEVEL6 AIã®ã‚¿ãƒ¼ãƒ³é–‹å§‹
            if (aiLevel === 6 && level6AI && level6AI.isInitialized) {
                level6AI.startGame(game, game.aiPlayer); 
                level6AI.startTurn(game, game.aiPlayer);
            }
            
            let placed = 0;
            const maxBlocks = game.remainingBlocks;

            async function placeOneBlock() {
                if (placed >= maxBlocks || !game.gameActive || game.currentPlayer !== game.aiPlayer) {
                    console.log("AIé…ç½®å®Œäº†");

                    // LEVEL6 AIã®ã‚¿ãƒ¼ãƒ³çµ‚äº†ï¼ˆã‚²ãƒ¼ãƒ ç¶™ç¶šä¸­ï¼‰
                    if (aiLevel === 6 && level6AI && level6AI.isInitialized) {
                        level6AI.endTurn(game, 'continue');
                    }
                    
                    game.aiThinking = false;
                    return;
                }

                let chosenMove = null;

                if (aiLevel === 1) {
                    chosenMove = getRandomMove();
                    console.log("Lv1ï¼ˆãƒ©ãƒ³ãƒ€ãƒ ï¼‰æˆ¦ç•¥ã§æ‰‹ã‚’é¸æŠ");
                    
                } else if (aiLevel === 2) {
                    console.log("=== ãƒ¬ãƒ™ãƒ«2AIå‹•ä½œé–‹å§‹ ===");
                    
                    try {
                        var winMove = findWinningMove(game.aiPlayer);
                        
                        if (winMove) {
                            console.log("ãƒ¬ãƒ™ãƒ«2: å‹åˆ©æ‰‹é¸æŠ");
                            chosenMove = winMove;
                        } else {
                            var blockMove = findBlockingMove(game.aiPlayer);
                            
                            if (blockMove) {
                                console.log("ãƒ¬ãƒ™ãƒ«2: é˜»æ­¢æ‰‹é¸æŠ");
                                chosenMove = blockMove;
                            } else {
                                chosenMove = getRandomMove();
                                console.log("ãƒ¬ãƒ™ãƒ«2: ãƒ©ãƒ³ãƒ€ãƒ æ‰‹é¸æŠ");
                            }
                        }
                    } catch (error) {
                        console.error("ãƒ¬ãƒ™ãƒ«2AIå‡¦ç†ã§ã‚¨ãƒ©ãƒ¼:", error);
                        chosenMove = getRandomMove();
                    }
                    
                } else if (aiLevel === 3) {
                    console.log("=== ãƒ¬ãƒ™ãƒ«3AIå‹•ä½œé–‹å§‹ ===");
                    
                    try {
                        var winMove = findWinningMove(game.aiPlayer);
                        
                        if (winMove) {
                            console.log("ãƒ¬ãƒ™ãƒ«3: å‹åˆ©æ‰‹é¸æŠ");
                            chosenMove = winMove;
                        } else {
                            var blockMove = findBlockingMove(game.aiPlayer);
                            
                            if (blockMove) {
                                console.log("ãƒ¬ãƒ™ãƒ«3: é˜»æ­¢æ‰‹é¸æŠ");
                                chosenMove = blockMove;
                            } else {
                                var twoMoveWin = findTwoMoveWin(game.aiPlayer);
                                
                                if (twoMoveWin) {
                                    console.log("ãƒ¬ãƒ™ãƒ«3: 2æ‰‹å‹åˆ©æ‰‹é¸æŠ");
                                    chosenMove = twoMoveWin;
                                } else {
                                    var opponent = game.aiPlayer === 1 ? 2 : 1;
                                    var opponentTwoMoveWin = findTwoMoveWin(opponent);
                                    
                                    if (opponentTwoMoveWin) {
                                        console.log("ãƒ¬ãƒ™ãƒ«3: ç›¸æ‰‹2æ‰‹å‹åˆ©é˜»æ­¢");
                                        chosenMove = opponentTwoMoveWin;
                                    } else {
                                        var centerMove = findCenterMove();
                                        
                                        if (centerMove) {
                                            console.log("ãƒ¬ãƒ™ãƒ«3: ä¸­å¤®åˆ¶åœ§æ‰‹é¸æŠ");
                                            chosenMove = centerMove;
                                        } else {
                                            chosenMove = getRandomMove();
                                        }
                                    }
                                }
                            }
                        }
                    } catch (error) {
                        console.error("ãƒ¬ãƒ™ãƒ«3AIå‡¦ç†ã§ã‚¨ãƒ©ãƒ¼:", error);
                        chosenMove = getRandomMove();
                    }
                    
                } else if (aiLevel === 4) {
                    console.log("=== ãƒ¬ãƒ™ãƒ«4AIå‹•ä½œé–‹å§‹ï¼ˆé˜²å¾¡æœ€å„ªå…ˆï¼‰===");
                    
                    try {
                        console.log("ãƒ¬ãƒ™ãƒ«4: å‹åˆ©æ‰‹æ¤œç´¢ä¸­...");
                        var winMove = findWinningMove(game.aiPlayer);
                        
                        if (winMove) {
                            console.log("ãƒ¬ãƒ™ãƒ«4: å³åº§å‹åˆ©æ‰‹é¸æŠ");
                            chosenMove = winMove;
                        } else {
                            console.log("ãƒ¬ãƒ™ãƒ«4: å³åº§å‹åˆ©é˜»æ­¢æ¤œç´¢ä¸­...");
                            var blockMove = findBlockingMove(game.aiPlayer);
                            
                            if (blockMove) {
                                console.log("ãƒ¬ãƒ™ãƒ«4: ç›¸æ‰‹å³åº§å‹åˆ©é˜»æ­¢");
                                chosenMove = blockMove;
                            } else {
                                console.log("ãƒ¬ãƒ™ãƒ«4: 4é€£ç·Šæ€¥é˜»æ­¢æ¤œç´¢ä¸­...");
                                var fourRowThreat = findFourInARowThreat(game.aiPlayer);
                                
                                if (fourRowThreat) {
                                    console.log("ãƒ¬ãƒ™ãƒ«4: â˜…ç·Šæ€¥â˜… 4é€£é˜»æ­¢æ‰‹é¸æŠ");
                                    chosenMove = fourRowThreat;
                                } else {
                                    console.log("ãƒ¬ãƒ™ãƒ«4: 3é€£è„…å¨é˜»æ­¢æ¤œç´¢ä¸­...");
                                    var threatBlockMove = findThreeInARowThreat(game.aiPlayer);
                                    
                                    if (threatBlockMove) {
                                        console.log("ãƒ¬ãƒ™ãƒ«4: 3é€£è„…å¨é˜»æ­¢æ‰‹é¸æŠ");
                                        chosenMove = threatBlockMove;
                                    } else {
                                        console.log("ãƒ¬ãƒ™ãƒ«4: è¤‡æ•°è„…å¨æ‰‹æ¤œç´¢ä¸­...");
                                        var multipleThreatMove = findMultipleThreatMove(game.aiPlayer);
                                        
                                        if (multipleThreatMove) {
                                            console.log("ãƒ¬ãƒ™ãƒ«4: è¤‡æ•°è„…å¨ä½œæˆæ‰‹é¸æŠ");
                                            chosenMove = multipleThreatMove;
                                        } else {
                                            console.log("ãƒ¬ãƒ™ãƒ«4: ç›¸æ‰‹è¤‡æ•°è„…å¨é˜»æ­¢æ¤œç´¢ä¸­...");
                                            var blockMultipleThreat = findMultipleThreatBlock(game.aiPlayer);
                                            
                                            if (blockMultipleThreat) {
                                                console.log("ãƒ¬ãƒ™ãƒ«4: ç›¸æ‰‹è¤‡æ•°è„…å¨é˜»æ­¢");
                                                chosenMove = blockMultipleThreat;
                                            } else {
                                                console.log("ãƒ¬ãƒ™ãƒ«4: é«˜è„…å¨æ‰‹æ¤œç´¢ä¸­...");
                                                var highThreatMove = findHighThreatMove(game.aiPlayer);
                                                
                                                if (highThreatMove) {
                                                    console.log("ãƒ¬ãƒ™ãƒ«4: é«˜è„…å¨æ‰‹é¸æŠ");
                                                    chosenMove = highThreatMove;
                                                } else {
                                                    console.log("ãƒ¬ãƒ™ãƒ«4: 2æ‰‹å‹åˆ©æ¤œç´¢ä¸­...");
                                                    var twoMoveWin = findTwoMoveWin(game.aiPlayer);
                                                    
                                                    if (twoMoveWin) {
                                                        console.log("ãƒ¬ãƒ™ãƒ«4: 2æ‰‹å‹åˆ©æ‰‹é¸æŠ");
                                                        chosenMove = twoMoveWin;
                                                    } else {
                                                        console.log("ãƒ¬ãƒ™ãƒ«4: ç›¸æ‰‹2æ‰‹å‹åˆ©é˜»æ­¢æ¤œç´¢ä¸­...");
                                                        var opponent = game.aiPlayer === 1 ? 2 : 1;
                                                        var opponentTwoMoveWin = findTwoMoveWin(opponent);
                                                        
                                                        if (opponentTwoMoveWin) {
                                                            console.log("ãƒ¬ãƒ™ãƒ«4: ç›¸æ‰‹2æ‰‹å‹åˆ©é˜»æ­¢");
                                                            chosenMove = opponentTwoMoveWin;
                                                        } else {
                                                            console.log("ãƒ¬ãƒ™ãƒ«4: ç¸¦2é€£+æœ¬å‘½æ”»æ’ƒæ¤œç´¢ä¸­...");
                                                            var verticalComboMove = findVerticalDoublePlusThreatMove(game.aiPlayer);
                                                            
                                                            if (verticalComboMove) {
                                                                console.log("ãƒ¬ãƒ™ãƒ«4: ç¸¦2é€£+æœ¬å‘½æ”»æ’ƒé¸æŠ");
                                                                chosenMove = verticalComboMove;
                                                            } else {
                                                                console.log("ãƒ¬ãƒ™ãƒ«4: ç›¸æ‰‹ç¸¦2é€£é˜»æ­¢æ¤œç´¢ä¸­...");
                                                                var verticalBlockMove = findVerticalDoubleBlock(game.aiPlayer);
                                                                
                                                                if (verticalBlockMove) {
                                                                    console.log("ãƒ¬ãƒ™ãƒ«4: ç›¸æ‰‹ç¸¦2é€£é˜»æ­¢é¸æŠ");
                                                                    chosenMove = verticalBlockMove;
                                                                } else {
                                                                    console.log("ãƒ¬ãƒ™ãƒ«4: ç¸¦2é€£ä½œæˆæ¤œç´¢ä¸­...");
                                                                    var verticalDoubleMove = findVerticalDoubleMove(game.aiPlayer);
                                                                    
                                                                    if (verticalDoubleMove) {
                                                                        console.log("ãƒ¬ãƒ™ãƒ«4: ç¸¦2é€£ä½œæˆæ‰‹é¸æŠ");
                                                                        chosenMove = verticalDoubleMove;
                                                                    } else {
                                                                        console.log("ãƒ¬ãƒ™ãƒ«4: ä¸­å¤®åˆ¶åœ§æ¤œç´¢ä¸­...");
                                                                        var centerMove = findCenterMove();
                                                                        
                                                                        if (centerMove) {
                                                                            console.log("ãƒ¬ãƒ™ãƒ«4: ä¸­å¤®åˆ¶åœ§æ‰‹é¸æŠ");
                                                                            chosenMove = centerMove;
                                                                        } else {
                                                                            console.log("ãƒ¬ãƒ™ãƒ«4: ãƒ©ãƒ³ãƒ€ãƒ æ‰‹é¸æŠ");
                                                                            chosenMove = getRandomMove();
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } catch (error) {
                        console.error("ãƒ¬ãƒ™ãƒ«4AIå‡¦ç†ã§ã‚¨ãƒ©ãƒ¼:", error);
                        chosenMove = getRandomMove();
                        console.log("ãƒ¬ãƒ™ãƒ«4: ã‚¨ãƒ©ãƒ¼å¾Œã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯");
                    }
                    
                } else if (aiLevel === 6) {
                    console.log("=== ãƒ¬ãƒ™ãƒ«6 æ©Ÿæ¢°å­¦ç¿’AIå‹•ä½œé–‹å§‹ ===");
                    
                    try {
                        if (!level6AI) {
                            level6AI = new Level6AI();
                            await level6AI.initializeModel();
                        }
                        
                        if (level6AI && level6AI.isInitialized) {
                            const validMoves = getAllValidMoves();
                            chosenMove = await level6AI.selectAction(game, game.aiPlayer, validMoves);
                            console.log(`LEVEL6é¸æŠ: (${chosenMove?.[0]}, ${chosenMove?.[1]})`);
                        } else {
                            chosenMove = getRandomMove();
                            console.log("LEVEL6ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: ãƒ©ãƒ³ãƒ€ãƒ ");
                        }
                    } catch (error) {
                        console.error("ãƒ¬ãƒ™ãƒ«6AIå‡¦ç†ã§ã‚¨ãƒ©ãƒ¼:", error);
                        chosenMove = getRandomMove();
                    }
                } else {
                    chosenMove = getRandomMove();
                    console.log("ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆï¼ˆãƒ©ãƒ³ãƒ€ãƒ ï¼‰æˆ¦ç•¥ã§æ‰‹ã‚’é¸æŠ");
                }

                console.log('AIé¸æŠã—ãŸæ‰‹:', chosenMove);

                if (chosenMove) {
                    console.log(`AIé…ç½®å®Ÿè¡Œ: (${chosenMove[0]}, ${chosenMove[1]})`);
                    // LEVEL6 AIã«ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’è¨˜éŒ²
                    if (aiLevel === 6 && level6AI && level6AI.isInitialized) {
                        level6AI.recordAction(chosenMove, game, game.aiPlayer);
                    }
                    placePiece(chosenMove[0], chosenMove[1], true);
                    placed++;
                    setTimeout(placeOneBlock, 600);
                } else {
                    console.warn("AIãŒæœ‰åŠ¹ãªæ‰‹ã‚’è¦‹ã¤ã‘ã‚‰ã‚Œã¾ã›ã‚“ã§ã—ãŸ");
                    game.aiThinking = false;
                }
            }

            placeOneBlock();
        }

        // Level4ç”¨ã®ä¸è¶³ã—ã¦ã„ã‚‹é–¢æ•°ç¾¤
        function findFourInARowThreat(player) {
            return findThreeInARowThreat(player);
        }

        function findDiagonalThreat(player) {
            return null;
        }

        function findFutureThreats(player) {
            return null;
        }

        function findAntiEncirclementMove(player) {
            return null;
        }

        function findEncirclementMove(player) {
            return null;
        }

        function findClusterMove(player) {
            return null;
        }

        // å‹åˆ©ãƒã‚§ãƒƒã‚¯
        function checkWin(row, col) {
            var player = game.grid[row][col];
            var directions = [
                [0, 1],  // æ¨ª
                [1, 0],  // ç¸¦
                [1, 1],  // æ–œã‚å³ä¸‹
                [1, -1]  // æ–œã‚å·¦ä¸‹
            ];

            for (var d = 0; d < directions.length; d++) {
                var dr = directions[d][0];
                var dc = directions[d][1];
                var line = [[row, col]];
                
                for (var i = 1; i < WIN_COUNT; i++) {
                    var r = row - dr * i;
                    var c = col - dc * i;
                    if (r >= 0 && r < GRID_HEIGHT && c >= 0 && c < GRID_WIDTH && 
                        game.grid[r][c] === player) {
                        line.unshift([r, c]);
                    } else {
                        break;
                    }
                }
                
                for (var i = 1; i < WIN_COUNT; i++) {
                    var r = row + dr * i;
                    var c = col + dc * i;
                    if (r >= 0 && r < GRID_HEIGHT && c >= 0 && c < GRID_WIDTH && 
                        game.grid[r][c] === player) {
                        line.push([r, c]);
                    } else {
                        break;
                    }
                }
                
                if (line.length >= WIN_COUNT) {
                    game.winningCells = line;
                    return true;
                }
            }
            
            return false;
        }

        // ã‚¿ãƒ¼ãƒ³äº¤ä»£ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³è¡¨ç¤º
        // æ–°ã—ã„ã‚¿ãƒ¼ãƒ³äº¤ä»£ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³è¡¨ç¤ºï¼ˆãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰æ ãƒã‚ªãƒ³ï¼‰
        function showTurnChangeAnimation(newPlayer) {
            const gridElement = document.getElementById('gameGrid');
            if (!gridElement) return;
            
            // æ—¢å­˜ã®ã‚¿ãƒ¼ãƒ³ã‚¯ãƒ©ã‚¹ã‚’å‰Šé™¤
            gridElement.classList.remove('player1-turn', 'player2-turn');
            
            // æ–°ã—ã„ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¿ãƒ¼ãƒ³ã‚¯ãƒ©ã‚¹ã‚’è¿½åŠ 
            const turnClass = `player${newPlayer}-turn`;
            gridElement.classList.add(turnClass);
            
            // 2ç§’å¾Œã«ã‚¯ãƒ©ã‚¹ã‚’å‰Šé™¤ï¼ˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³çµ‚äº†ï¼‰
            //ä»¥ä¸‹ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆã—ã¾ã™
            //setTimeout(() => {
            //    gridElement.classList.remove(turnClass);
            //}, 2000);
            
            console.log(`ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰æ ãƒã‚ªãƒ³æ¼”å‡º: ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼${newPlayer}`);
        }
        
        // ã‚¢ãƒ©ãƒ¼ãƒˆè¡¨ç¤º
        function showAlert(message) {
            var existingAlert = document.querySelector('.alert');
            if (existingAlert) {
                existingAlert.remove();
            }
            
            var alert = document.createElement('div');
            alert.className = 'alert';
            alert.textContent = message;
            document.body.appendChild(alert);
            
            setTimeout(function() {
                alert.remove();
            }, 2000);
        }

        // ã‚²ãƒ¼ãƒ çµ‚äº†
      async function endGame(winner) {

          
            console.log(`ã‚²ãƒ¼ãƒ çµ‚äº†å‡¦ç†é–‹å§‹ - å‹è€…: ${winner}`);
            
            game.gameActive = false;
            clearInterval(game.timer);
            
            clearWinningCells();
            game.aiThinking = false;
        
            // LEVEL6 AIå­¦ç¿’å‡¦ç†
            if (level6AI && aiLevel === 6 && level6AI.isInitialized) {
                let result = 'draw';
                if (winner === game.aiPlayer) {
                    result = 'win';
                } else if (winner !== 0 && winner !== game.aiPlayer) {
                    result = 'lose';
                }
                
                // awaitä½¿ç”¨å¯èƒ½
                await level6AI.onGameEnd(result, game.aiPlayer);
                
                // ãƒ¡ãƒ¢ãƒªæ•°ã®æ›´æ–°
                const memoryElement = document.getElementById('memoryCount');
                if (memoryElement) {
                    memoryElement.textContent = level6AI.memory.length;
                }
            }


            var modal = document.getElementById('gameModal');
            var message = document.getElementById('modalMessage');
            var title = document.getElementById('modalTitle');
            var icon = document.getElementById('winnerIcon');

            if (winner === 1) {
                if (game.isAI && game.aiPlayer === 1) {
                    title.textContent = 'ğŸ¤– AIã®å‹åˆ©ï¼';
                } else {
                    title.textContent = 'ğŸ‰ ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼1ã®å‹åˆ©ï¼';
                }
                icon.style.background = '#ef4444';
            } else if (winner === 2) {
                if (game.isAI && game.aiPlayer === 2) {
                    title.textContent = 'ğŸ¤– AIã®å‹åˆ©ï¼';
                } else {
                    title.textContent = 'ğŸ‰ ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼2ã®å‹åˆ©ï¼';
                }
                icon.style.background = '#3b82f6';
            } else {
                title.textContent = 'ğŸ¤ ã‚²ãƒ¼ãƒ çµ‚äº†';
                icon.style.background = '#9ca3af';
            }

            // AIé€²åŒ–ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
            if (game.isAI && aiLevel === 6 && level6AI) {
                const evolutionMsg = getEvolutionMessage();
                message.textContent = evolutionMsg + '\n\nå†æˆ¦ã§AIã‚’ã•ã‚‰ã«æˆé•·ã•ã›ã¾ã™ã‹ï¼Ÿ';
            } else {
                message.textContent = 'ã‚²ãƒ¼ãƒ ãŒçµ‚äº†ã—ã¾ã—ãŸã€‚å†æˆ¦ã—ã¾ã™ã‹ï¼Ÿ';
            }
            modal.style.display = 'block';
            
            console.log("ã‚²ãƒ¼ãƒ çµ‚äº†ãƒ¢ãƒ¼ãƒ€ãƒ«è¡¨ç¤ºå®Œäº†");
        }

        async function endGameNow() {
            
            await endGame(0);
        }

        // LEVEL6åˆ¶å¾¡é–¢æ•°
        function onAILevelChange() {
            const level = parseInt(document.getElementById('aiLevelSelect').value);
            const mlContainer = document.getElementById('mlStatusContainer');
            
            if (level === 6) {
                mlContainer.style.display = 'block';
                if (!level6AI) {
                    level6AI = new Level6AI();
                    level6AI.initializeModel();
                }
            } else {
                mlContainer.style.display = 'none';
            }
        }

        function toggleMLTraining() {
            if (level6AI) {
                level6AI.toggleTraining();
                const btn = document.getElementById('mlToggleBtn');
                btn.textContent = `å­¦ç¿’ãƒ¢ãƒ¼ãƒ‰: ${level6AI.isTraining ? 'ON' : 'OFF'}`;
            }
        }

        function resetMLAI() {
            if (level6AI && confirm('AIå­¦ç¿’ãƒ‡ãƒ¼ã‚¿ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã™ã‹ï¼Ÿ')) {
                level6AI.reset();
            }
        }

        function exportMLData() {
            if (level6AI) {
                const data = {
                    // åŸºæœ¬çµ±è¨ˆ
                    gamesPlayed: level6AI.gamesPlayed,
                    wins: level6AI.wins,
                    winRate: level6AI.winRate,
                    epsilon: level6AI.epsilon,
                    
                    // å­¦ç¿’å±¥æ­´
                    lossHistory: level6AI.lossHistory,
                    winRateHistory: level6AI.winRateHistory,
                    rewardHistory: level6AI.rewardHistory,
                    
                    // ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿
                    memorySize: level6AI.memory.length,
                    maxMemory: level6AI.maxMemory,
                    batchSize: level6AI.batchSize,
                    exportTime: new Date().toISOString(),
                    
                    // è©³ç´°å­¦ç¿’ãƒ‡ãƒ¼ã‚¿ï¼ˆæœ€æ–°100ä»¶ã®ã¿ï¼‰
                    recentMemory: level6AI.memory.slice(-100),
                    
                    // æˆé•·æ®µéš
                    stage: level6AI.gamesPlayed > 200 ? 'ãƒã‚¹ã‚¿ãƒ¼' :
                           level6AI.gamesPlayed > 100 ? 'ã‚¨ã‚­ã‚¹ãƒ‘ãƒ¼ãƒˆ' :
                           level6AI.gamesPlayed > 60 ? 'ç†Ÿç·´' :
                           level6AI.gamesPlayed > 30 ? 'æˆé•·æœŸ' :
                           level6AI.gamesPlayed > 15 ? 'å­¦ç¿’ä¸­' :
                           level6AI.gamesPlayed > 5 ? 'å¹¼å…' : 'èª•ç”Ÿ'
                };
                
                const blob = new Blob([JSON.stringify(data, null, 2)], {
                    type: 'application/json'
                });
                
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `level6_ai_data_${level6AI.gamesPlayed}games_${data.stage}.json`;
                a.click();
                URL.revokeObjectURL(url);
                
                console.log(`AIãƒ‡ãƒ¼ã‚¿ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆå®Œäº†: ${level6AI.gamesPlayed}æˆ¦, å‹ç‡${(level6AI.winRate*100).toFixed(1)}%`);
            }
        }

window.startGame = startGame;
window.onAILevelChange = onAILevelChange;
window.toggleMLTraining = toggleMLTraining;
window.resetMLAI = resetMLAI;
window.exportMLData = exportMLData;
window.showLearningGraph = showLearningGraph;
window.saveMLManually = saveMLManually;
window.showStart = showStart;
window.endGameNow = endGameNow;
        function getEvolutionMessage() {
            if (!level6AI) return 'ã‚²ãƒ¼ãƒ ãŒçµ‚äº†ã—ã¾ã—ãŸã€‚';
            
            const games = level6AI.gamesPlayed;
            const winRate = level6AI.winRate;
            
            if (games <= 5) {
                return `ğŸ¼ AIã¯${games}å›ç›®ã®ä½“é¨“ã§ã—ãŸã€‚ã¾ã å­¦ç¿’ã‚’å§‹ã‚ãŸã°ã‹ã‚Šã§ã™ã€‚`;
            } else if (games <= 15) {
                return `ğŸ‘¶ AIã¯${games}æˆ¦ã®çµŒé¨“ã‚’ç©ã¿ã¾ã—ãŸã€‚åŸºæœ¬ã‚’è¦šãˆå§‹ã‚ã¦ã„ã¾ã™ã€‚`;
            } else if (games <= 30) {
                return `ğŸ§’ AIã¯${games}æˆ¦ã§å‹ç‡${(winRate*100).toFixed(1)}%ã§ã™ã€‚æˆ¦ç•¥ã‚’å­¦ç¿’ä¸­ã§ã™ã€‚`;
            } else if (games <= 60) {
                return `ğŸ§‘â€ğŸ“ AIã¯${games}æˆ¦ã§å‹ç‡${(winRate*100).toFixed(1)}%ã‚’é”æˆã€‚ã‹ãªã‚Šæˆé•·ã—ã¾ã—ãŸï¼`;
            } else if (games <= 100) {
                return `ğŸ† AIã¯${games}æˆ¦ã®è±Šå¯ŒãªçµŒé¨“ã§å‹ç‡${(winRate*100).toFixed(1)}%ã€‚ç†Ÿç·´ã®åŸŸã§ã™ï¼`;
            } else {
                return `ğŸ¯ AIã¯${games}æˆ¦ã®ãƒã‚¹ã‚¿ãƒ¼ã‚¯ãƒ©ã‚¹ã€å‹ç‡${(winRate*100).toFixed(1)}%ã€‚ã‚ãªãŸã®æœ€å¼·ã®å¯¾æˆ¦ç›¸æ‰‹ã§ã™ï¼`;
            }
        }

        function showLearningGraph() {
            if (!level6AI || level6AI.winRateHistory.length < 5) {
                alert('å­¦ç¿’ãƒ‡ãƒ¼ã‚¿ãŒä¸è¶³ã—ã¦ã„ã¾ã™ã€‚5æˆ¦ä»¥ä¸Šãƒ—ãƒ¬ã‚¤ã—ã¦ãã ã•ã„ã€‚');
                return;
            }
            
            const canvas = document.createElement('canvas');
            canvas.width = 400;
            canvas.height = 300;
            canvas.style.border = '1px solid #ddd';
            canvas.style.borderRadius = '5px';
            
            const ctx = canvas.getContext('2d');
            
            // èƒŒæ™¯
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, 400, 300);
            
            // å‹ç‡ã‚°ãƒ©ãƒ•
            const winRates = level6AI.winRateHistory.slice(-50); // æœ€æ–°50ä»¶
            const maxY = 280;
            const minY = 20;
            const maxX = 380;
            const minX = 20;
            
            ctx.strokeStyle = '#3b82f6';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            for (let i = 0; i < winRates.length; i++) {
                const x = minX + (i / (winRates.length - 1)) * (maxX - minX);
                const y = maxY - (winRates[i] * (maxY - minY));
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();
            
            // è»¸ã¨ãƒ©ãƒ™ãƒ«
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 1;
            
            // Yè»¸
            ctx.beginPath();
            ctx.moveTo(minX, minY);
            ctx.lineTo(minX, maxY);
            ctx.stroke();
            
            // Xè»¸
            ctx.beginPath();
            ctx.moveTo(minX, maxY);
            ctx.lineTo(maxX, maxY);
            ctx.stroke();
            
            // ãƒ©ãƒ™ãƒ«
            ctx.fillStyle = '#333';
            ctx.font = '12px Arial';
            ctx.fillText('å‹ç‡', 5, 15);
            ctx.fillText('0%', 5, maxY);
            ctx.fillText('100%', 5, minY + 15);
            ctx.fillText('å¯¾æˆ¦å±¥æ­´ï¼ˆæœ€æ–°50æˆ¦ï¼‰', 150, 295);
            
            // ãƒ¢ãƒ¼ãƒ€ãƒ«è¡¨ç¤º
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.7); z-index: 2000; display: flex;
                align-items: center; justify-content: center;
            `;
            
            const content = document.createElement('div');
            content.style.cssText = `
                background: white; padding: 20px; border-radius: 10px;
                text-align: center; max-width: 90%;
            `;
            
            const title = document.createElement('h3');
            title.textContent = 'LEVEL6 AI å­¦ç¿’é€²åŒ–ã‚°ãƒ©ãƒ•';
            title.style.margin = '0 0 15px 0';
            
            const closeBtn = document.createElement('button');
            closeBtn.textContent = 'é–‰ã˜ã‚‹';
            closeBtn.style.cssText = `
                margin-top: 15px; padding: 8px 16px; background: #3b82f6;
                color: white; border: none; border-radius: 5px; cursor: pointer;
            `;
            closeBtn.onclick = () => document.body.removeChild(modal);
            
            content.appendChild(title);
            content.appendChild(canvas);
            content.appendChild(closeBtn);
            modal.appendChild(content);
            document.body.appendChild(modal);
        }

        async function saveMLManually() {
            if (level6AI && level6AI.isInitialized) {
                try {
                    await level6AI.saveModel();
                    level6AI.saveStatistics();
                    alert('AIãƒ‡ãƒ¼ã‚¿ã‚’æ‰‹å‹•ä¿å­˜ã—ã¾ã—ãŸï¼');
                } catch (error) {
                    alert('ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + error.message);
                }
            } else {
                alert('AIãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚');
            }
        }


    </script>
</body>
</html>
