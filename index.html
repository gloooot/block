<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ドロップファイブ</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tensorflow/4.10.0/tf.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
        }

        .card {
            background: white;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .start-screen {
            text-align: center;
            padding: 40px;
        }

        .game-title {
            font-size: 3em;
            color: #333;
            margin-bottom: 20px;
        }

        .rules {
            text-align: left;
            margin: 20px 0;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .rules ul {
            margin: 10px 0;
            padding-left: 20px;
        }

        .rules li {
            margin: 8px 0;
        }

        .btn {
            background: linear-gradient(135deg, #8b5cf6 0%, #ec4899 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 8px;
            font-size: 18px;
            cursor: pointer;
            transition: transform 0.2s;
            margin: 10px;
        }

        .btn:hover {
            transform: translateY(-2px);
        }

        .btn.ai-mode {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
        }

        .game-screen {
            display: none;
        }

        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .game-status {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .players {
            display: flex;
            gap: 30px;
        }

        .player {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 18px;
        }

        .player.active {
            font-weight: bold;
        }

        .player.ai {
            font-style: italic;
        }

        .player-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
        }

        .red { background: #ef4444; }
        .blue { background: #3b82f6; }

        .timer {
            font-size: 24px;
            font-weight: bold;
        }

        .timer.warning {
            color: #ef4444;
            animation: blink 1s infinite;
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            font-size: 14px;
            color: #666;
        }

        .grid-container {
            text-align: center;
            padding: 20px;
            overflow-x: auto;
        }

       .grid {
            display: inline-grid;
            grid-template-columns: repeat(15, 32px);
            gap: 2px;
            background: #ddd;
            padding: 10px;
            border-radius: 8px;
            min-width: max-content;
        }

        .cell {
            width: 32px;
            height: 32px;
            background: white;
            border: 3px solid transparent;
            box-sizing: border-box;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            transition: all 0.3s;
        }

        .cell:hover {
            background: #f0f0f0;
            border-color: #ddd;
        }

        .cell.ground {
            background: #fef3c7;
            border-bottom-color: #d97706;
        }

        .cell.red {
            background: #ef4444;
            color: white;
            border-color: #dc2626;
        }

        .cell.blue {
            background: #3b82f6;
            color: white;
            border-color: #2563eb;
        }

        .cell.winning {
            border-color: #fbbf24;
            animation: winningBlink 1s infinite;
            box-shadow: 0 0 10px #fbbf24;
        }

        .cell.dropping {
            animation: drop 0.5s ease-out;
        }

        .ground-label {
            margin-top: 15px;
            color: #d97706;
            font-weight: bold;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
        }

        .modal-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 40px;
            border-radius: 10px;
            text-align: center;
            max-width: 400px;
            width: 90%;
        }

        .winner-icon {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            margin: 0 auto 20px;
        }

        .alert {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #ef4444;
            color: white;
            padding: 15px 25px;
            border-radius: 8px;
            font-weight: bold;
            z-index: 1001;
            animation: alertShow 0.3s ease-out;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.5; }
        }

        @keyframes winningBlink {
            0%, 100% { 
                border-color: #fbbf24;
                box-shadow: 0 0 10px #fbbf24;
            }
            50% { 
                border-color: #f59e0b;
                box-shadow: 0 0 20px #f59e0b;
            }
        }

        @keyframes drop {
            0% { transform: translateY(-20px); opacity: 0.7; }
            100% { transform: translateY(0); opacity: 1; }
        }

        @keyframes turnFlash {
            0% { transform: scale(1); opacity: 1; }
            30% { transform: scale(1.3); opacity: 0.8; }
            60% { transform: scale(1); opacity: 1; }
            100% { transform: scale(1); opacity: 1; }
        }

        .player.flash {
            animation: turnFlash 0.8s ease-out;
            color: #fbbf24;
        }

        @keyframes alertShow {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
            100% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }

        /* ターン交代アニメーション */
        @keyframes turnChange {
            0% { 
                transform: scale(1);
                background-color: transparent;
            }
            25% { 
                transform: scale(1.1);
                background-color: rgba(251, 191, 36, 0.3);
                border-radius: 8px;
            }
            50% { 
                transform: scale(1.15);
                background-color: rgba(251, 191, 36, 0.5);
            }
            75% { 
                transform: scale(1.1);
                background-color: rgba(251, 191, 36, 0.3);
            }
            100% { 
                transform: scale(1);
                background-color: transparent;
            }
        }

        @keyframes turnNotification {
            0% { 
                opacity: 0;
                transform: translateY(-20px) scale(0.8);
            }
            20% { 
                opacity: 1;
                transform: translateY(0) scale(1.1);
            }
            80% { 
                opacity: 1;
                transform: translateY(0) scale(1);
            }
            100% { 
                opacity: 0;
                transform: translateY(-10px) scale(0.9);
            }
        }

        .player.turn-change {
            animation: turnChange 1.2s ease-out;
        }

        .turn-notification {
            position: fixed;
            top: 20%;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, #8b5cf6 0%, #ec4899 100%);
            color: white;
            padding: 15px 25px;
            border-radius: 25px;
            font-weight: bold;
            font-size: 18px;
            z-index: 1500;
            animation: turnNotification 1.5s ease-out;
            box-shadow: 0 10px 25px rgba(0,0,0,0.3);
            text-align: center;
            min-width: 200px;
        }

        .turn-notification.ai-turn {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
        }

        /* プレイヤー名のフラッシュ効果強化 */
        .player.flash {
            animation: turnFlash 1s ease-out;
            position: relative;
        }

        @keyframes turnFlash {
            0% { 
                transform: scale(1); 
                color: inherit;
                text-shadow: none;
            }
            25% { 
                transform: scale(1.2); 
                color: #fbbf24;
                text-shadow: 0 0 10px rgba(251, 191, 36, 0.8);
            }
            50% { 
                transform: scale(1.1); 
                color: #f59e0b;
                text-shadow: 0 0 15px rgba(245, 158, 11, 0.9);
            }
            75% { 
                transform: scale(1.15); 
                color: #fbbf24;
                text-shadow: 0 0 10px rgba(251, 191, 36, 0.8);
            }
            100% { 
                transform: scale(1); 
                color: inherit;
                text-shadow: none;
            }
        }
        
        /* タブレット対応 */
        @media (max-width: 768px) {
            .grid-container {
                padding: 15px 10px;
            }
            
            .grid {
                grid-template-columns: repeat(15, 24px);
                gap: 1px;
                padding: 8px;
            }
            
            .cell {
                width: 24px;
                height: 24px;
                font-size: 14px;
            }
            
            .game-status {
                flex-direction: column;
                gap: 15px;
            }
            
            .players {
                gap: 20px;
            }
        }

        /* スマホ対応 */
        @media (max-width: 600px) {
            .grid-container {
                padding: 10px 5px;
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }
            
            .grid {
                grid-template-columns: repeat(15, 18px);
                gap: 1px;
                padding: 6px;
                margin: 0 auto;
            }
            
            .cell {
                width: 18px;
                height: 18px;
                font-size: 11px;
                border-width: 2px;
            }
            
            .game-status {
                flex-direction: column;
                gap: 10px;
            }
            
            .players {
                gap: 15px;
                justify-content: center;
            }
            
            .game-info {
                flex-direction: column;
                gap: 5px;
                text-align: center;
            }
            
            .btn {
                padding: 12px 20px;
                font-size: 16px;
            }
        }

        /* 小さいスマホ対応 */
        @media (max-width: 480px) {
            .container {
                padding: 10px;
            }
            
            .grid-container {
                padding: 8px 2px;
            }
            
            .grid {
                grid-template-columns: repeat(15, 16px);
                gap: 1px;
                padding: 4px;
                font-size: 10px;
            }
            
            .cell {
                width: 16px;
                height: 16px;
                font-size: 10px;
                border-width: 1px;
            }
            
            .game-header {
                flex-direction: column;
                gap: 10px;
                text-align: center;
            }
            
            .game-header h2 {
                font-size: 1.5em;
                margin: 0;
            }
            
            .players {
                flex-direction: row;
                gap: 10px;
            }
            
            .player {
                font-size: 14px;
            }
            
            .timer {
                font-size: 20px;
            }
        }

        

        /* LEVEL6専用スタイル */
        .ml-container {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
            color: white;
        }

        .ml-status {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .ml-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 5px;
        }

        .ml-indicator.loading { background: #fbbf24; animation: pulse 1s infinite; }
        .ml-indicator.training { background: #10b981; animation: pulse 1s infinite; }
        .ml-indicator.ready { background: #3b82f6; }
        .ml-indicator.error { background: #ef4444; }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(255,255,255,0.3);
            border-radius: 4px;
            overflow: hidden;
            margin: 5px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #10b981, #3b82f6);
            transition: width 0.3s ease;
        }

        .ml-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            font-size: 12px;
        }

        .stat-item {
            text-align: center;
            padding: 5px;
            background: rgba(255,255,255,0.1);
            border-radius: 5px;
        }

        .stat-value {
            font-weight: bold;
            font-size: 14px;
            display: block;
        }

        .ml-controls {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .ml-btn {
            background: rgba(255,255,255,0.2);
            border: 1px solid rgba(255,255,255,0.3);
            color: white;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .ml-btn:hover {
            background: rgba(255,255,255,0.3);
        }

        .ai-thinking {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            z-index: 1002;
            text-align: center;
        }

        .thinking-spinner {
            border: 3px solid rgba(255,255,255,0.3);
            border-top: 3px solid #3b82f6;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- スタート画面 -->
        <div id="startScreen" class="card start-screen">
            <h1 class="game-title">ドロップファイブ</h1>
            <p>2人対戦ブロック配置パズルゲーム</p>
            
            <div class="rules">
                <h3>📋 ゲームルール</h3>
                <ul>
                    <li>先行プレイヤーの色のブロックが中央に1個配置されます</li>
                    <li>先行は初手で1個のみ配置可能</li>
                    <li>2ターン目以降は各プレイヤーが1ターンに2個配置</li>
                    <li>縦・横・斜めのいずれかで5個連続に並べると勝利</li>
                    <li>1階（地面）では隣接するブロックが必要</li>
                    <li>2階以上では隣接制限なし</li>
                    <li>ブロックは重力で自動的に落下</li>
                    <li>制限時間内に配置しないと負け</li>
                </ul>
            </div>

            <!-- LEVEL6 AI状況表示 -->
            <div id="mlStatusContainer" class="ml-container" style="display: none;">
                <div class="ml-status">
                    <div>
                        <span class="ml-indicator loading" id="mlIndicator"></span>
                        <span id="mlStatusText">LEVEL6 AI 初期化中...</span>
                    </div>
                    <button class="ml-btn" id="mlToggleBtn" onclick="toggleMLTraining()">
                        学習モード: ON
                    </button>
                </div>
                
                <div class="progress-bar">
                    <div class="progress-fill" id="mlProgress" style="width: 0%"></div>
                </div>
                
              
                <div class="ml-stats">
                    <div class="stat-item">
                        <span class="stat-value" id="gamesCount">0</span>
                        <span>対戦数</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-value" id="winRate">0%</span>
                        <span>勝率</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-value" id="explorationRate">100%</span>
                        <span>探索率</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-value" id="learningStage">準備中</span>
                        <span>成長段階</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-value" id="latestLoss">---</span>
                        <span>学習誤差</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-value" id="avgReward">---</span>
                        <span>平均報酬</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-value" id="evolutionTrend">準備中</span>
                        <span>進化傾向</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-value" id="memoryCount">0</span>
                        <span>記憶数</span>
                    </div>
                </div>
                
               <div class="ml-controls">
                    <button class="ml-btn" id="resetMLBtn" onclick="resetMLAI()">AIリセット</button>
                    <button class="ml-btn" id="exportMLBtn" onclick="exportMLData()">データ出力</button>
                    <button class="ml-btn" id="showGraphBtn" onclick="showLearningGraph()">学習グラフ</button>
                    <button class="ml-btn" id="saveMLBtn" onclick="saveMLManually()">手動保存</button>
                </div>
            </div>

            <div style="margin: 20px 0;">
                <label style="font-weight: bold; color: #333;">🤖 AIの強さを選ぶ：</label><br>
              <select id="aiLevelSelect" style="padding: 8px 16px; font-size: 16px; border-radius: 6px;" onchange="onAILevelChange()">
                    <option value="1">Lv1（幼児レベル）</option>
                    <option value="2">Lv2（ガキレベル）</option>
                    <option value="3">Lv3（中坊レベル）</option>
                    <option value="4">Lv4（間の悪い大人レベル）</option>
                    <option value="6">Lv6（藤井壮太幼少期レベル）🧠</option>
                </select>
            </div>
            
            <button class="btn" onclick="startGame(false)">👥 2人対戦</button>
            <button class="btn ai-mode" onclick="startGame(true)">🤖 AIと対戦</button>
        </div>

        <!-- ゲーム画面 -->
        <div id="gameScreen" class="game-screen">
            <!-- ヘッダー -->
            <div class="card">
                <div class="game-header">
                    <h2>ドロップファイブ</h2>
                    <div>
                        <button class="btn" onclick="showStart()">新しいゲーム</button>
                        <button class="btn" onclick="endGameNow()" style="background: #dc2626; margin-left: 10px;">ゲーム終了</button>
                    </div>
                </div>
            </div>

            <!-- ゲーム状況 -->
            <div class="card">
                <div class="game-status">
                    <div class="players">
                        <div class="player" id="player1">
                            <div class="player-color red"></div>
                            <span>プレイヤー1</span>
                        </div>
                        <div class="player" id="player2">
                            <div class="player-color blue"></div>
                            <span>プレイヤー2</span>
                        </div>
                    </div>
                    <div class="timer" id="timer">5:00</div>
                </div>
                <div class="game-info">
                    <div>現在のターン: <span id="currentPlayer">プレイヤー1</span></div>
                    <div>残りブロック: <span id="remainingBlocks">1</span>/<span id="maxBlocks">1</span></div>
                </div>
            </div>

            <!-- ゲームボード -->
            <div class="card grid-container">
                <div class="grid" id="gameGrid"></div>
                <div class="ground-label">⬆️ 地面レベル（隣接ブロック必要）</div>
            </div>
        </div>

        <!-- ゲーム終了モーダル -->
        <div id="gameModal" class="modal">
            <div class="modal-content">
                <h2 id="modalTitle">ゲーム終了</h2>
                <div class="winner-icon" id="winnerIcon"></div>
                <p id="modalMessage">結果メッセージ</p>
                <button class="btn" onclick="startGame(false)">2人対戦</button>
                <button class="btn ai-mode" onclick="startGame(true)">AIと対戦</button>
            </div>
        </div>
    </div>

    <!-- AI思考中表示 -->
    <div id="aiThinkingModal" class="ai-thinking" style="display: none;">
        <div class="thinking-spinner"></div>
        <div id="thinkingText">LEVEL6 AI 思考中...</div>
        <div id="thinkingDetails" style="font-size: 12px; margin-top: 10px; opacity: 0.8;"></div>
    </div>

    <script>
        // ゲーム設定
        var GRID_WIDTH = 15;
        var GRID_HEIGHT = 12;
        var WIN_COUNT = 5;
        var BLOCKS_PER_TURN = 2;
        var aiLevel = 1;
        var level6AI = null;

        // ゲーム状態
        var game = {
            grid: [],
            currentPlayer: 1,
            firstPlayer: 1,
            aiPlayer: null,
            remainingBlocks: 1,
            timeLeft: 30,
            gameActive: false,
            timer: null,
            animating: false,
            winningCells: [],
            showingWin: false,
            turnCount: 0,
            isAI: false,
            aiThinking: false
        };

        // LEVEL6 機械学習AI
        // LEVEL6 機械学習AI
        // LEVEL6 機械学習AI
      // LEVEL6 機械学習AI 実学習版（本当に学習する）
      // LEVEL6 機械学習AI 安定修正版（エラー完全解決）
        class Level6AI {
            constructor() {
                this.isInitialized = false;
                this.isTraining = true;
                this.model = null;
                this.memory = [];
                this.gamesPlayed = 0;
                this.wins = 0;
                this.winRate = 0;
                this.epsilon = 1.0;
                this.epsilonMin = 0.1;
                this.epsilonDecay = 0.99;
                this.maxMemory = 500;
                this.batchSize = 16;
                
                // ターン管理
                this.currentTurn = null;
                this.gameExperiences = [];
                
                // 統計・可視化
                this.lossHistory = [];
                this.winRateHistory = [];
                this.rewardHistory = [];
                this.trainingCount = 0;
                
                // 保存キー
                this.modelKey = 'localstorage://dropfive-ai-lv6-stable';
                this.statsKey = 'dropfive-ai-lv6-stable-stats';
                
                console.log("🧠 安定版Level6AI初期化開始");
            }

            async initializeModel() {
                try {
                    this.showStatus('loading', '安定版AI初期化中...');
                    this.updateProgress(20);
                    
                    // 保存されたモデルの読み込み
                    await this.loadModel();
                    
                    if (!this.model) {
                        this.showStatus('loading', '新規モデル構築中...');
                        this.updateProgress(50);
                        this.createStableModel();
                        console.log("🧠 新規モデル構築完了");
                    } else {
                        console.log("📥 保存済みモデル読み込み完了");
                    }
                    
                    this.updateProgress(80);
                    
                    // 統計データ読み込み
                    this.loadStatistics();
                    console.log("📊 統計データ読み込み完了");

                    this.isInitialized = true;
                    this.showStatus('ready', '安定版AI準備完了');
                    this.updateProgress(100);
                    
                    // UI更新を最後に実行
                    this.updateUI();
                    
                    console.log("✅ 安定版Level6AI初期化完了");
                    
                } catch (error) {
                    console.error("安定版AI初期化エラー:", error);
                    console.error("エラー詳細:", error.message || "詳細不明");
                    this.showStatus('error', 'AI初期化失敗');
                    
                    // 最小限のフォールバック
                    try {
                        this.createMinimalModel();
                        this.isInitialized = true;
                        this.showStatus('ready', '最小版AI準備完了');
                        console.log("⚠️ 最小モデルで動作開始");
                    } catch (fallbackError) {
                        console.error("フォールバック失敗:", fallbackError);
                        this.showStatus('error', 'AI完全失敗');
                    }
                }
            }

            createStableModel() {
                try {
                    this.model = tf.sequential({
                        layers: [
                            tf.layers.dense({ 
                                inputShape: [180], 
                                units: 128, 
                                activation: 'relu'
                            }),
                            tf.layers.dropout({ rate: 0.3 }),
                            tf.layers.dense({ 
                                units: 64, 
                                activation: 'relu'
                            }),
                            tf.layers.dense({ 
                                units: 180, 
                                activation: 'linear'
                            })
                        ]
                    });

                    this.model.compile({
                        optimizer: tf.train.adam(0.001),
                        loss: 'meanSquaredError'
                    });
                } catch (error) {
                    console.error("安定モデル作成エラー:", error);
                    throw error;
                }
            }

            createMinimalModel() {
                this.model = tf.sequential({
                    layers: [
                        tf.layers.dense({ 
                            inputShape: [180], 
                            units: 64, 
                            activation: 'relu'
                        }),
                        tf.layers.dense({ 
                            units: 180, 
                            activation: 'linear'
                        })
                    ]
                });

                this.model.compile({
                    optimizer: 'adam',
                    loss: 'meanSquaredError'
                });
            }

            async loadModel() {
                try {
                    this.model = await tf.loadLayersModel(this.modelKey);
                    console.log("📥 保存済みモデル読み込み成功");
                } catch (error) {
                    console.log("📝 新規モデル作成");
                    this.model = null;
                }
            }

            async saveModel() {
                if (this.model && this.isInitialized) {
                    try {
                        await this.model.save(this.modelKey);
                        console.log("💾 モデル保存完了");
                    } catch (error) {
                        console.error("💾 モデル保存エラー:", error);
                    }
                }
            }

            loadStatistics() {
                try {
                    const saved = localStorage.getItem(this.statsKey);
                    if (saved) {
                        const data = JSON.parse(saved);
                        this.gamesPlayed = data.gamesPlayed || 0;
                        this.wins = data.wins || 0;
                        this.winRate = data.winRate || 0;
                        this.epsilon = data.epsilon || 1.0;
                        this.lossHistory = data.lossHistory || [];
                        this.winRateHistory = data.winRateHistory || [];
                        this.trainingCount = data.trainingCount || 0;
                        console.log(`📊 統計読み込み: ${this.gamesPlayed}戦, 勝率${(this.winRate*100).toFixed(1)}%`);
                    }
                } catch (error) {
                    console.error("統計読み込みエラー:", error);
                    // エラーでも続行
                    this.gamesPlayed = 0;
                    this.wins = 0;
                    this.winRate = 0;
                }
            }

            saveStatistics() {
                try {
                    const data = {
                        gamesPlayed: this.gamesPlayed,
                        wins: this.wins,
                        winRate: this.winRate,
                        epsilon: this.epsilon,
                        lossHistory: this.lossHistory.slice(-100),
                        winRateHistory: this.winRateHistory.slice(-100),
                        trainingCount: this.trainingCount
                    };
                    localStorage.setItem(this.statsKey, JSON.stringify(data));
                } catch (error) {
                    console.error("統計保存エラー:", error);
                }
            }

            startGame(gameState, currentPlayer) {
                this.gameExperiences = [];
                console.log(`🎮 ゲーム開始 - プレイヤー${currentPlayer}`);
            }

            startTurn(gameState, currentPlayer) {
                this.currentTurn = {
                    player: currentPlayer,
                    startState: this.encodeState(gameState, currentPlayer),
                    actions: [],
                    rewards: []
                };
                console.log(`🎯 ターン開始 - プレイヤー${currentPlayer}`);
            }

            recordAction(action, gameState, currentPlayer) {
                if (this.currentTurn && this.currentTurn.player === currentPlayer) {
                    this.currentTurn.actions.push(action);
                    
                    const immediateReward = this.calculateImmediateReward(gameState, currentPlayer, action);
                    this.currentTurn.rewards.push(immediateReward);
                    
                    console.log(`📝 行動記録 ${this.currentTurn.actions.length}/2: (${action[0]}, ${action[1]}) 報酬:${immediateReward.toFixed(3)}`);
                }
            }

            endTurn(finalGameState, finalResult) {
                if (!this.currentTurn) return;
                
                if (this.currentTurn.actions.length > 0) {
                    const experience = {
                        state: this.currentTurn.startState,
                        actions: this.currentTurn.actions.slice(),
                        immediateRewards: this.currentTurn.rewards.slice(),
                        player: this.currentTurn.player,
                        timestamp: Date.now()
                    };
                    
                    this.gameExperiences.push(experience);
                    console.log(`📋 ターン経験保存: ${this.currentTurn.actions.length}手, 累計報酬:${this.currentTurn.rewards.reduce((a,b)=>a+b,0).toFixed(3)}`);
                }

                this.currentTurn = null;
            }

            calculateImmediateReward(gameState, currentPlayer, action) {
                let reward = 0;
                const opponent = currentPlayer === 1 ? 2 : 1;
                const [row, col] = action;
                
                // 連結数ボーナス
                gameState.grid[row][col] = currentPlayer;
                const myConnections = this.countConnections(gameState, row, col, currentPlayer);
                
                if (myConnections >= 5) {
                    reward += 10.0;  // 勝利確定
                } else if (myConnections >= 4) {
                    reward += 3.0;   // 4連
                } else if (myConnections >= 3) {
                    reward += 1.0;   // 3連
                } else if (myConnections >= 2) {
                    reward += 0.3;   // 2連
                }
                
                gameState.grid[row][col] = 0;
                
                // 相手阻止ボーナス
                gameState.grid[row][col] = opponent;
                const opponentConnections = this.countConnections(gameState, row, col, opponent);
                
                if (opponentConnections >= 5) {
                    reward += 8.0;   // 相手勝利阻止
                } else if (opponentConnections >= 4) {
                    reward += 2.0;   // 相手4連阻止
                } else if (opponentConnections >= 3) {
                    reward += 0.5;   // 相手3連阻止
                }
                
                gameState.grid[row][col] = 0;
                
                // 中央優位
                const centerCol = Math.floor(GRID_WIDTH / 2);
                const distanceFromCenter = Math.abs(col - centerCol);
                reward += Math.max(0, 0.1 - distanceFromCenter * 0.01);
                
                return reward;
            }

            countConnections(gameState, row, col, player) {
                const directions = [[0,1], [1,0], [1,1], [1,-1]];
                let maxConnection = 1;
                
                for (const [dr, dc] of directions) {
                    let count = 1;
                    
                    for (let i = 1; i < 5; i++) {
                        const r = row + dr * i;
                        const c = col + dc * i;
                        if (r >= 0 && r < GRID_HEIGHT && c >= 0 && c < GRID_WIDTH && 
                            gameState.grid[r] && gameState.grid[r][c] === player) {
                            count++;
                        } else break;
                    }
                    
                    for (let i = 1; i < 5; i++) {
                        const r = row - dr * i;
                        const c = col - dc * i;
                        if (r >= 0 && r < GRID_HEIGHT && c >= 0 && c < GRID_WIDTH && 
                            gameState.grid[r] && gameState.grid[r][c] === player) {
                            count++;
                        } else break;
                    }
                    
                    maxConnection = Math.max(maxConnection, count);
                }
                
                return maxConnection;
            }

            async onGameEnd(result, aiPlayer) {
                this.gamesPlayed++;
                
                if (result === 'win') {
                    this.wins++;
                }
                
                this.winRate = this.wins / this.gamesPlayed;
                this.winRateHistory.push(this.winRate);
                
                console.log(`🏁 ゲーム終了: ${result} (${this.gamesPlayed}戦目, 勝率${(this.winRate*100).toFixed(1)}%)`);
                
                // 最終報酬設定
                this.assignFinalRewards(result, aiPlayer);
                
                // 学習実行
                await this.trainAfterGame();
                
                // UI更新
                this.updateUI();
            }

            assignFinalRewards(result, aiPlayer) {
                if (this.gameExperiences.length === 0) {
                    console.log("⚠️ 学習用経験データなし");
                    return;
                }
                
                let finalReward = 0;
                if (result === 'win') {
                    finalReward = 5.0;
                } else if (result === 'lose') {
                    finalReward = -3.0;
                } else {
                    finalReward = 0.0;
                }
                
                console.log(`🎖️ 最終報酬設定: ${finalReward} (結果: ${result})`);
                
                for (let exp of this.gameExperiences) {
                    if (exp.player === aiPlayer) {
                        const totalReward = exp.immediateRewards.reduce((a, b) => a + b, 0) + finalReward;
                        
                        const finalExperience = {
                            state: exp.state,
                            actions: exp.actions,
                            reward: totalReward,
                            timestamp: exp.timestamp
                        };
                        
                        this.memory.push(finalExperience);
                        console.log(`💾 経験保存: ${exp.actions.length}手, 総報酬:${totalReward.toFixed(3)}`);
                    }
                }
                
                while (this.memory.length > this.maxMemory) {
                    this.memory.shift();
                }
                
                console.log(`📊 現在の経験数: ${this.memory.length}/${this.maxMemory}`);
            }

            async trainAfterGame() {
                if (this.memory.length < this.batchSize || !this.isTraining) {
                    console.log(`⏸️ 学習スキップ: 経験数${this.memory.length} < 必要数${this.batchSize}`);
                    return;
                }

                try {
                    this.showStatus('training', '学習実行中...');
                    this.trainingCount++;
                    
                    console.log(`🧠 学習開始 ${this.trainingCount}回目`);
                    
                    const batch = this.sampleBatch();
                    const states = batch.map(exp => exp.state);
                    const targets = this.calculateTargets(batch);

                    const statesTensor = tf.tensor2d(states);
                    const targetsTensor = tf.tensor2d(targets);

                    const history = await this.model.fit(statesTensor, targetsTensor, {
                        epochs: 2,
                        verbose: 0,
                        batchSize: this.batchSize
                    });

                    const loss = history.history.loss[history.history.loss.length - 1];
                    this.lossHistory.push(loss);
                    
                    console.log(`📈 学習完了! Loss: ${loss.toFixed(4)}, Epsilon: ${(this.epsilon*100).toFixed(1)}%`);

                    statesTensor.dispose();
                    targetsTensor.dispose();

                    if (this.epsilon > this.epsilonMin) {
                        this.epsilon *= this.epsilonDecay;
                    }

                    if (this.gamesPlayed % 5 === 0) {
                        await this.saveModel();
                        this.saveStatistics();
                        console.log("💾 定期保存完了");
                    }

                    this.showStatus('ready', '安定版AI準備完了');
                    
                } catch (error) {
                    console.error("🚨 学習エラー:", error);
                    this.showStatus('error', '学習失敗');
                }
            }

            calculateTargets(batch) {
                const targets = [];
                
                for (const experience of batch) {
                    const target = new Array(180).fill(0);
                    
                    for (const action of experience.actions) {
                        const actionIndex = action[0] * 15 + action[1];
                        if (actionIndex < 180) {
                            target[actionIndex] = experience.reward;
                        }
                    }
                    
                    targets.push(target);
                }
                
                return targets;
            }

            sampleBatch() {
                const batch = [];
                for (let i = 0; i < Math.min(this.batchSize, this.memory.length); i++) {
                    const randomIndex = Math.floor(Math.random() * this.memory.length);
                    batch.push(this.memory[randomIndex]);
                }
                return batch;
            }

            async selectAction(gameState, currentPlayer, validMoves) {
                if (!this.isInitialized || !this.model || validMoves.length === 0) {
                    return this.fallbackAction(validMoves);
                }

                try {
                    this.showThinking("AI戦略分析中...");

                    if (this.isTraining && Math.random() < this.epsilon) {
                        this.hideThinking();
                        const randomMove = this.fallbackAction(validMoves);
                        console.log(`🎲 探索行動: (${randomMove[0]}, ${randomMove[1]}) ε=${(this.epsilon*100).toFixed(1)}%`);
                        return randomMove;
                    }

                    const stateVector = this.encodeState(gameState, currentPlayer);
                    const stateTensor = tf.tensor2d([stateVector]);
                    const qValues = await this.model.predict(stateTensor);
                    const qArray = await qValues.data();

                    let bestMove = null;
                    let bestQ = -Infinity;

                    for (const move of validMoves) {
                        const actionIndex = move[0] * 15 + move[1];
                        if (actionIndex < qArray.length && qArray[actionIndex] > bestQ) {
                            bestQ = qArray[actionIndex];
                            bestMove = move;
                        }
                    }

                    stateTensor.dispose();
                    qValues.dispose();

                    this.hideThinking();
                    
                    if (bestMove) {
                        console.log(`🧠 学習行動: (${bestMove[0]}, ${bestMove[1]}) Q値=${bestQ.toFixed(3)}`);
                    }
                    
                    return bestMove || this.fallbackAction(validMoves);

                } catch (error) {
                    console.error("思考エラー:", error);
                    this.hideThinking();
                    return this.fallbackAction(validMoves);
                }
            }

            encodeState(gameState, currentPlayer) {
                const vector = new Array(180).fill(0);
                let index = 0;

                for (let row = 0; row < 12; row++) {
                    for (let col = 0; col < 15; col++) {
                        const cell = gameState.grid[row] ? gameState.grid[row][col] || 0 : 0;
                        vector[index++] = cell === currentPlayer ? 1 : (cell === 0 ? 0 : -1);
                    }
                }

                return vector;
            }

            fallbackAction(validMoves) {
                if (validMoves.length === 0) return null;
                return validMoves[Math.floor(Math.random() * validMoves.length)];
            }

            updateUI() {
                try {
                    // 安全なDOM操作
                    const elements = {
                        gamesCount: document.getElementById('gamesCount'),
                        winRate: document.getElementById('winRate'),
                        explorationRate: document.getElementById('explorationRate'),
                        learningStage: document.getElementById('learningStage'),
                        latestLoss: document.getElementById('latestLoss'),
                        avgReward: document.getElementById('avgReward'),
                        evolutionTrend: document.getElementById('evolutionTrend'),
                        memoryCount: document.getElementById('memoryCount')
                    };
                    
                    if (elements.gamesCount) {
                        elements.gamesCount.textContent = this.gamesPlayed;
                    }
                    
                    if (elements.winRate) {
                        elements.winRate.textContent = (this.winRate * 100).toFixed(1) + '%';
                    }
                    
                    if (elements.explorationRate) {
                        elements.explorationRate.textContent = (this.epsilon * 100).toFixed(1) + '%';
                    }
                    
                    // 成長段階
                    if (elements.learningStage) {
                        let stage = '胎児';
                        let stageColor = '#ef4444';
                        if (this.gamesPlayed > 3) { stage = '幼児'; stageColor = '#f59e0b'; }
                        if (this.gamesPlayed > 10) { stage = '学習期'; stageColor = '#10b981'; }
                        if (this.gamesPlayed > 25) { stage = '成長期'; stageColor = '#3b82f6'; }
                        if (this.gamesPlayed > 50) { stage = '熟練期'; stageColor = '#8b5cf6'; }
                        if (this.gamesPlayed > 100) { stage = 'エキスパート'; stageColor = '#ec4899'; }
                        
                        elements.learningStage.textContent = stage;
                        elements.learningStage.style.color = stageColor;
                    }
                    
                    // 学習誤差
                    if (elements.latestLoss && this.lossHistory.length > 0) {
                        const latestLoss = this.lossHistory[this.lossHistory.length - 1];
                        elements.latestLoss.textContent = latestLoss.toFixed(4);
                    }
                    
                    // 平均報酬
                    if (elements.avgReward && this.memory.length > 0) {
                        const recentRewards = this.memory.slice(-10).map(exp => exp.reward);
                        const avgReward = recentRewards.reduce((a, b) => a + b, 0) / recentRewards.length;
                        elements.avgReward.textContent = avgReward.toFixed(3);
                    }

                    // 進化傾向
                    this.updateEvolutionTrend(elements.evolutionTrend);
                    
                    // メモリ数
                    if (elements.memoryCount) {
                        elements.memoryCount.textContent = this.memory.length;
                    }
                    
                } catch (error) {
                    console.error("UI更新エラー:", error);
                    // UI更新エラーでも続行
                }
            }

            updateEvolutionTrend(trendElement) {
                if (!trendElement || this.winRateHistory.length < 5) return;
                
                try {
                    const recent = this.winRateHistory.slice(-5);
                    const older = this.winRateHistory.slice(-10, -5);
                    
                    if (older.length === 0) return;
                    
                    const recentAvg = recent.reduce((a, b) => a + b, 0) / recent.length;
                    const olderAvg = older.reduce((a, b) => a + b, 0) / older.length;
                    
                    const diff = recentAvg - olderAvg;
                    let trendText = '→';
                    let trendColor = '#6b7280';
                    
                    if (diff > 0.2) {
                        trendText = '🚀 爆成長';
                        trendColor = '#10b981';
                    } else if (diff > 0.1) {
                        trendText = '📈 急成長';
                        trendColor = '#10b981';
                    } else if (diff > 0.05) {
                        trendText = '↗️ 成長中';
                        trendColor = '#3b82f6';
                    } else if (diff < -0.1) {
                        trendText = '↘️ 調整期';
                        trendColor = '#f59e0b';
                    } else {
                        trendText = '→ 安定期';
                        trendColor = '#8b5cf6';
                    }
                    
                    trendElement.textContent = trendText;
                    trendElement.style.color = trendColor;
                } catch (error) {
                    console.error("進化傾向更新エラー:", error);
                }
            }

            showStatus(type, message) {
                try {
                    const indicator = document.getElementById('mlIndicator');
                    const text = document.getElementById('mlStatusText');
                    
                    if (indicator) indicator.className = `ml-indicator ${type}`;
                    if (text) text.textContent = message;
                } catch (error) {
                    console.error("ステータス表示エラー:", error);
                }
            }

            updateProgress(percent) {
                try {
                    const progress = document.getElementById('mlProgress');
                    if (progress) progress.style.width = percent + '%';
                } catch (error) {
                    console.error("プログレス更新エラー:", error);
                }
            }

            showThinking(message) {
                try {
                    const modal = document.getElementById('aiThinkingModal');
                    const text = document.getElementById('thinkingText');
                    
                    if (text) text.textContent = message;
                    if (modal) modal.style.display = 'block';
                } catch (error) {
                    console.error("思考表示エラー:", error);
                }
            }

            hideThinking() {
                try {
                    const modal = document.getElementById('aiThinkingModal');
                    if (modal) modal.style.display = 'none';
                } catch (error) {
                    console.error("思考非表示エラー:", error);
                }
            }

            toggleTraining() {
                this.isTraining = !this.isTraining;
                console.log(`🎓 学習モード: ${this.isTraining ? 'ON' : 'OFF'}`);
            }

            reset() {
                try {
                    this.memory = [];
                    this.gameExperiences = [];
                    this.gamesPlayed = 0;
                    this.wins = 0;
                    this.winRate = 0;
                    this.epsilon = 1.0;
                    this.lossHistory = [];
                    this.winRateHistory = [];
                    this.trainingCount = 0;
                    
                    if (this.model) {
                        this.model.dispose();
                    }
                    this.createStableModel();
                    
                    localStorage.removeItem(this.statsKey);
                    this.saveModel();
                    this.saveStatistics();
                    
                    this.updateUI();
                    console.log("🔄 安定版AI完全リセット完了");
                } catch (error) {
                    console.error("リセットエラー:", error);
                }
            }
        }

        // ★★★ 全ての関数定義（function宣言でhoisting利用） ★★★
        
        // グリッド初期化
        function initGrid() {
            game.grid = [];
            for (var row = 0; row < GRID_HEIGHT; row++) {
                game.grid[row] = [];
                for (var col = 0; col < GRID_WIDTH; col++) {
                    game.grid[row][col] = 0;
                }
            }
        }
        function resetGameState() {
        clearInterval(game.timer);
        clearWinningCells();
        game.grid = [];
        game.currentPlayer = 1;
        game.firstPlayer = 1;
        game.aiPlayer = null;
        game.remainingBlocks = 1;
        game.timeLeft = 30;
        game.gameActive = false;
        game.timer = null;
        game.animating = false;
        game.winningCells = [];
        game.showingWin = false;
        game.turnCount = 0;
        game.isAI = false;
        game.aiThinking = false;
    }


        // 勝利ラインを表示する関数
        function showWinningCells() {
            console.log("勝利ライン表示:", game.winningCells);
        }

        // 勝利ラインをクリアする関数
        function clearWinningCells() {
            game.winningCells = [];
            console.log("勝利ラインクリア");
        }

        // ゲーム開始関数
        function startGame(isVsAI) {
            GRID_WIDTH = 15;
            GRID_HEIGHT = 12;
            if (typeof isVsAI === 'undefined') {
                isVsAI = false;
            }
            
            var levelSelect = document.getElementById('aiLevelSelect');
            aiLevel = levelSelect ? parseInt(levelSelect.value) : 1;

            initGrid();
            game.firstPlayer = Math.random() > 0.5 ? 1 : 2;
            game.currentPlayer = game.firstPlayer;
            
            if (isVsAI) {
                game.aiPlayer = Math.random() > 0.5 ? 1 : 2;
            } else {
                game.aiPlayer = null;
            }
            
            game.remainingBlocks = 1;
            game.timeLeft = 30;
            game.gameActive = true;
            game.animating = false;
            clearWinningCells();
            game.showingWin = false;
            game.turnCount = 0;
            game.isAI = isVsAI;
            game.aiThinking = false;

            var centerCol = Math.floor(GRID_WIDTH / 2);
            var groundRow = GRID_HEIGHT - 1;
            game.grid[groundRow][centerCol] = game.firstPlayer;

            console.log(`ゲーム開始 - 先攻: プレイヤー${game.firstPlayer}, AI: プレイヤー${game.aiPlayer}`);

            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('gameScreen').style.display = 'block';
            document.getElementById('gameModal').style.display = 'none';

            createGrid();
            updateDisplay();
            startTimer();
            
            if (game.isAI && game.currentPlayer === game.aiPlayer) {
                   // 最初のターン表示
                setTimeout(() => {
                    showTurnChangeAnimation(game.currentPlayer);
                }, 300);
                console.log("AIが先攻で動作開始");
                setTimeout(cpuPlay, 1500);
            }
        }

        // タイマー開始
        function startTimer() {
            clearInterval(game.timer);
            
            game.timer = setInterval(function() {
                game.timeLeft--;
                updateDisplay();
                
                if (game.timeLeft <= 0) {
                    clearInterval(game.timer);
                    var winner = game.currentPlayer === 1 ? 2 : 1;
                    showAlert(`プレイヤー${game.currentPlayer}のタイムアウト！`);
                    setTimeout(async function() {
                        await endGame(winner);
                    }, 2000);
                }
            }, 1000);
        }

        // スタート画面表示
        function showStart() {
            clearInterval(game.timer);
            clearWinningCells();
            game.aiThinking = false;
            
            document.getElementById('startScreen').style.display = 'block';
            document.getElementById('gameScreen').style.display = 'none';
            document.getElementById('gameModal').style.display = 'none';
        }

        // グリッド作成
        function createGrid() {
            var gridElement = document.getElementById('gameGrid');
            gridElement.innerHTML = '';
            
            updateGridTemplate();

            for (var row = 0; row < GRID_HEIGHT; row++) {
                for (var col = 0; col < GRID_WIDTH; col++) {
                    var cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    cell.onclick = function() {
                        var clickedRow = parseInt(this.dataset.row);
                        var clickedCol = parseInt(this.dataset.col);
                        placePiece(clickedRow, clickedCol);
                    };

                    if (row === GRID_HEIGHT - 1) {
                        cell.classList.add('ground');
                    }

                    gridElement.appendChild(cell);
                }
            }
        }

        // 画面表示更新
        function updateDisplay() {
            document.getElementById('player1').classList.toggle('active', game.currentPlayer === 1);
            document.getElementById('player2').classList.toggle('active', game.currentPlayer === 2);
            
            if (game.isAI) {
                var aiElement = game.aiPlayer === 1 ? 
                    document.getElementById('player1') : 
                    document.getElementById('player2');
                aiElement.classList.add('ai');
                aiElement.querySelector('span').textContent = `AI (Lv${aiLevel})`;
                
                var humanElement = game.aiPlayer === 1 ? 
                    document.getElementById('player2') : 
                    document.getElementById('player1');
                humanElement.classList.remove('ai');
                humanElement.querySelector('span').textContent = game.aiPlayer === 1 ? 'プレイヤー2' : 'プレイヤー1';
            } else {
                document.getElementById('player1').classList.remove('ai');
                document.getElementById('player2').classList.remove('ai');
                document.getElementById('player1').querySelector('span').textContent = 'プレイヤー1';
                document.getElementById('player2').querySelector('span').textContent = 'プレイヤー2';
            }
            
            var currentPlayerName;
            if (game.currentPlayer === 1) {
                currentPlayerName = (game.isAI && game.aiPlayer === 1) ? `AI (Lv${aiLevel})` : 'プレイヤー1';
            } else {
                currentPlayerName = (game.isAI && game.aiPlayer === 2) ? `AI (Lv${aiLevel})` : 'プレイヤー2';
            }
            document.getElementById('currentPlayer').textContent = currentPlayerName;
            
            document.getElementById('remainingBlocks').textContent = game.remainingBlocks;
            var maxBlocks = game.turnCount === 0 ? 1 : BLOCKS_PER_TURN;
            document.getElementById('maxBlocks').textContent = maxBlocks;
            
            var minutes = Math.floor(game.timeLeft / 60);
            var seconds = game.timeLeft % 60;
            var timerElement = document.getElementById('timer');
            timerElement.textContent = minutes + ':' + seconds.toString().padStart(2, '0');
            timerElement.classList.toggle('warning', game.timeLeft <= 30);

            updateGrid();
        }

        // グリッド表示更新
        function updateGrid() {
            var cells = document.querySelectorAll('.cell');
            var index = 0;
            
            for (var row = 0; row < GRID_HEIGHT; row++) {
                for (var col = 0; col < GRID_WIDTH; col++) {
                    var cell = cells[index];
                    if (!cell) continue;
                    
                    var value = game.grid[row][col];
                    
                    cell.className = 'cell';
                    if (row === GRID_HEIGHT - 1) {
                        cell.classList.add('ground');
                    }
                    
                    if (value === 1) {
                        cell.classList.add('red');
                        cell.textContent = '●';
                    } else if (value === 2) {
                        cell.classList.add('blue');
                        cell.textContent = '●';
                    } else {
                        cell.textContent = '';
                    }
                    
                    index++;
                }
            }
            
            if (game.showingWin && game.winningCells.length > 0) {
                for (var w = 0; w < game.winningCells.length; w++) {
                    var r = game.winningCells[w][0];
                    var c = game.winningCells[w][1];
                    var idx = r * GRID_WIDTH + c;
                    if (cells[idx]) {
                        cells[idx].classList.add('winning');
                    }
                }
            }
        }

        // 地面配置チェック
        function isValidGroundPlacement(col) {
            var groundRow = GRID_HEIGHT - 1;
            var leftCol = col - 1;
            var rightCol = col + 1;
            
            if (leftCol >= 0 && game.grid[groundRow][leftCol] !== 0) {
                return true;
            }
            if (rightCol < GRID_WIDTH && game.grid[groundRow][rightCol] !== 0) {
                return true;
            }
            
            return false;
        }

        // 配置可能かチェック
        function isValidPlacement(row, col) {
            if (row < 0 || row >= GRID_HEIGHT || col < 0 || col >= GRID_WIDTH) {
                return false;
            }
            if (game.grid[row][col] !== 0) {
                return false;
            }
            if (row < GRID_HEIGHT - 1 && game.grid[row + 1][col] === 0) {
                return false;
            }
            if (row === GRID_HEIGHT - 1 && !isValidGroundPlacement(col)) {
                return false;
            }
            return true;
        }

        // 有効な手をすべて取得
        function getAllValidMoves() {
            var validMoves = [];
            
            for (var row = 0; row < GRID_HEIGHT; row++) {
                for (var col = 0; col < GRID_WIDTH; col++) {
                    if (game.grid[row][col] !== 0) continue;
                    
                    var hasSupport = (row === GRID_HEIGHT - 1) || 
                                    (row + 1 < GRID_HEIGHT && game.grid[row + 1][col] !== 0);
                    
                    if (hasSupport) {
                        if (row === GRID_HEIGHT - 1) {
                            if (isValidGroundPlacement(col)) {
                                validMoves.push([row, col]);
                            }
                        } else {
                            validMoves.push([row, col]);
                        }
                    }
                }
            }
            
            return validMoves;
        }

        // ランダムな手を選択
        function getRandomMove() {
            const validMoves = getAllValidMoves();
            if (validMoves.length === 0) return null;
            const randomIndex = Math.floor(Math.random() * validMoves.length);
            return validMoves[randomIndex];
        }

        // 勝利可能な手を探す
        function findWinningMove(player) {
            console.log(`勝利手検索開始 - プレイヤー${player}`);
            
            var originalWinningCells = game.winningCells.slice();
            
            for (var row = 0; row < GRID_HEIGHT; row++) {
                for (var col = 0; col < GRID_WIDTH; col++) {
                    if (game.grid[row][col] !== 0) continue;
                    if (!isValidPlacement(row, col)) continue;
                    
                    game.grid[row][col] = player;
                    var canWin = checkWin(row, col);
                    game.grid[row][col] = 0;
                    
                    if (canWin) {
                        console.log(`勝利手発見: (${row}, ${col}) - プレイヤー${player}が勝利`);
                        game.winningCells = originalWinningCells;
                        return [row, col];
                    }
                }
            }
            
            game.winningCells = originalWinningCells;
            console.log("勝利手なし");
            return null;
        }

        // 試合段階判定
        function getGamePhase() {
            var totalBlocks = 0;
            for (var row = 0; row < GRID_HEIGHT; row++) {
                for (var col = 0; col < GRID_WIDTH; col++) {
                    if (game.grid[row][col] !== 0) {
                        totalBlocks++;
                    }
                }
            }
            
            if (totalBlocks < 15) {
                return 'early';
            } else if (totalBlocks < 30) {
                return 'middle';
            } else {
                return 'late';
            }
        }

        // 縦2連作成戦略
        function findVerticalDoubleMove(player) {
            console.log(`縦2連作成戦略検索開始 - プレイヤー${player}`);
            
            var validMoves = getAllValidMoves();
            var bestMove = null;
            var bestScore = 0;
            
            for (var i = 0; i < validMoves.length; i++) {
                var move = validMoves[i];
                var row = move[0];
                var col = move[1];
                
                game.grid[row][col] = player;
                var verticalScore = evaluateVerticalDouble(row, col, player);
                game.grid[row][col] = 0;
                
                if (verticalScore > bestScore) {
                    bestScore = verticalScore;
                    bestMove = move;
                }
            }
            
            if (bestMove && bestScore > 50) {
                console.log(`縦2連作成手選択: (${bestMove[0]}, ${bestMove[1]}) - スコア:${bestScore}`);
                return bestMove;
            }
            
            console.log("有効な縦2連作成手なし");
            return null;
        }

        // 縦2連効果評価
        function evaluateVerticalDouble(row, col, player) {
            var score = 0;
            
            if (row < GRID_HEIGHT - 1 && game.grid[row + 1][col] === player) {
                score += 80;
                
                if (row < GRID_HEIGHT - 2 && game.grid[row + 2][col] === player) {
                    score += 120;
                }
                
                if (row > 0 && game.grid[row - 1][col] === 0) {
                    score += 60;
                }
            }
            
            if (row > 0 && game.grid[row - 1][col] === player) {
                score += 70;
                
                if (row > 1 && game.grid[row - 2][col] === player) {
                    score += 100;
                }
            }
            
            var centerCol = Math.floor(GRID_WIDTH / 2);
            var distanceFromCenter = Math.abs(col - centerCol);
            score += Math.max(0, 20 - distanceFromCenter * 2);
            
            return score;
        }

        // 縦2連 + 本命攻撃戦略
        function findVerticalDoublePlusThreatMove(player) {
            var gamePhase = getGamePhase();
            
            if (gamePhase !== 'late') {
                console.log(`縦2連+本命攻撃: ${gamePhase}のためスキップ（30個以上で発動）`);
                return null;
            }
            
            console.log(`縦2連+本命攻撃検索開始 - プレイヤー${player} (終盤戦略)`);
            
            var verticalDoubles = [];
            for (var row = 0; row < GRID_HEIGHT - 1; row++) {
                for (var col = 0; col < GRID_WIDTH; col++) {
                    if (game.grid[row][col] === player && game.grid[row + 1][col] === player) {
                        if (row > 0 && game.grid[row - 1][col] === 0 && isValidPlacement(row - 1, col)) {
                            verticalDoubles.push({
                                extendPos: [row - 1, col],
                                baseRow: row + 1,
                                score: 90
                            });
                        }
                    }
                }
            }
            
            if (verticalDoubles.length === 0) {
                console.log("活用可能な縦2連なし");
                return null;
            }
            
            console.log(`活用可能な縦2連: ${verticalDoubles.length}個発見`);
            
            var validMoves = getAllValidMoves();
            var bestComboMove = null;
            var bestComboScore = 0;
            
            for (var i = 0; i < validMoves.length; i++) {
                var move = validMoves[i];
                var row = move[0];
                var col = move[1];
                
                game.grid[row][col] = player;
                
                var threats = findConsecutiveBlocks(player, 2);
                var mainThreatScore = 0;
                
                for (var t = 0; t < threats.length; t++) {
                    mainThreatScore += evaluateThreat(threats[t], player);
                }
                
                game.grid[row][col] = 0;
                
                if (mainThreatScore > 200) {
                    for (var v = 0; v < verticalDoubles.length; v++) {
                        var vDouble = verticalDoubles[v];
                        
                        if (row !== vDouble.extendPos[0] || col !== vDouble.extendPos[1]) {
                            var comboScore = mainThreatScore + vDouble.score + 150;
                            
                            if (comboScore > bestComboScore) {
                                bestComboScore = comboScore;
                                bestComboMove = move;
                            }
                        }
                    }
                }
            }
            
            if (bestComboMove && bestComboScore > 400) {
                console.log(`縦2連+本命攻撃手選択: (${bestComboMove[0]}, ${bestComboMove[1]}) - コンボスコア:${bestComboScore}`);
                return bestComboMove;
            }
            
            console.log("有効な縦2連+本命攻撃なし");
            return null;
        }

        // 相手の縦2連阻止
        function findVerticalDoubleBlock(player) {
            var opponent = player === 1 ? 2 : 1;
            var gamePhase = getGamePhase();
            
            if (gamePhase !== 'late') {
                console.log(`相手縦2連阻止: ${gamePhase}のためスキップ（30個以上で発動）`);
                return null;
            }
            
            console.log(`相手縦2連阻止検索 - 相手プレイヤー${opponent} (終盤戦略)`);
            
            var dangerousVerticalDoubles = [];
            
            for (var row = 0; row < GRID_HEIGHT - 1; row++) {
                for (var col = 0; col < GRID_WIDTH; col++) {
                    if (game.grid[row][col] === opponent && game.grid[row + 1][col] === opponent) {
                        if (row > 0 && game.grid[row - 1][col] === 0 && isValidPlacement(row - 1, col)) {
                            var dangerLevel = 120;
                            
                            var centerCol = Math.floor(GRID_WIDTH / 2);
                            var distanceFromCenter = Math.abs(col - centerCol);
                            dangerLevel += Math.max(0, 20 - distanceFromCenter * 2);
                            
                            dangerousVerticalDoubles.push({
                                blockPos: [row - 1, col],
                                danger: dangerLevel
                            });
                        }
                    }
                }
            }
            
            if (dangerousVerticalDoubles.length > 0) {
                dangerousVerticalDoubles.sort(function(a, b) { return b.danger - a.danger; });
                var mostDangerous = dangerousVerticalDoubles[0];
                
                console.log(`危険な相手縦2連阻止: (${mostDangerous.blockPos[0]}, ${mostDangerous.blockPos[1]}) - 危険度:${mostDangerous.danger}`);
                return mostDangerous.blockPos;
            }
            
            console.log("阻止すべき相手縦2連なし");
            return null;
        }

        // 相手の勝利を阻止する手を探す
        function findBlockingMove(player) {
            var opponent = player === 1 ? 2 : 1;
            console.log(`阻止手検索開始 - 相手プレイヤー${opponent}の勝利を阻止`);
            
            var originalWinningCells = game.winningCells.slice();
            
            for (var row = 0; row < GRID_HEIGHT; row++) {
                for (var col = 0; col < GRID_WIDTH; col++) {
                    if (game.grid[row][col] !== 0) continue;
                    if (!isValidPlacement(row, col)) continue;
                    
                    game.grid[row][col] = opponent;
                    var opponentWins = checkWin(row, col);
                    game.grid[row][col] = 0;
                    
                    if (opponentWins) {
                        console.log(`阻止手発見: (${row}, ${col}) - 相手プレイヤー${opponent}の勝利を阻止`);
                        game.winningCells = originalWinningCells;
                        return [row, col];
                    }
                }
            }
            
            game.winningCells = originalWinningCells;
            console.log("阻止手なし");
            return null;
        }

        // 3連脅威を検出・阻止する専用関数
        function findThreeInARowThreat(player) {
            var opponent = player === 1 ? 2 : 1;
            console.log(`3連脅威検索開始 - 相手プレイヤー${opponent}`);
            
            var originalWinningCells = game.winningCells.slice();
            var threats = [];

            var consecutiveBlocks = findConsecutiveBlocks(opponent, 3);
            
            for (var i = 0; i < consecutiveBlocks.length; i++) {
                var blockInfo = consecutiveBlocks[i];
                var line = blockInfo.line;
                var direction = blockInfo.direction;
                var extendable = blockInfo.extendable;
                var isGround = blockInfo.isGround;

                var threatLevel = 0;
                var blockPositions = [];

                if (line.length === 3) {
                    if (direction === 1) {
                        console.log(`危険な縦3連検出:`, line);
                        threatLevel = 900;
                        
                        for (var j = 0; j < extendable.length; j++) {
                            var pos = extendable[j];
                            if (pos[0] < line[0][0]) {
                                if (isValidPlacement(pos[0], pos[1])) {
                                    blockPositions.push(pos);
                                }
                            }
                        }
                    } else if (direction === 0 && isGround) {
                        console.log(`危険な地面横3連検出:`, line);
                        threatLevel = 950;
                        
                        for (var j = 0; j < extendable.length; j++) {
                            var pos = extendable[j];
                            if (isValidPlacement(pos[0], pos[1])) {
                                blockPositions.push(pos);
                            }
                        }
                    } else if (direction === 0) {
                        console.log(`横3連検出:`, line);
                        threatLevel = 700;
                        
                        for (var j = 0; j < extendable.length; j++) {
                            var pos = extendable[j];
                            if (isValidPlacement(pos[0], pos[1])) {
                                blockPositions.push(pos);
                            }
                        }
                    } else {
                        console.log(`斜め3連検出:`, line);
                        threatLevel = 600;
                        
                        for (var j = 0; j < extendable.length; j++) {
                            var pos = extendable[j];
                            if (isValidPlacement(pos[0], pos[1])) {
                                blockPositions.push(pos);
                            }
                        }
                    }
                } else if (line.length === 4) {
                    console.log(`極めて危険な4連検出:`, line);
                    threatLevel = 1000;
                    
                    for (var j = 0; j < extendable.length; j++) {
                        var pos = extendable[j];
                        if (isValidPlacement(pos[0], pos[1])) {
                            blockPositions.push(pos);
                        }
                    }
                }

                if (blockPositions.length > 0) {
                    threats.push({
                        level: threatLevel,
                        positions: blockPositions,
                        type: direction === 1 ? '縦' : (direction === 0 ? (isGround ? '地面横' : '横') : '斜め'),
                        length: line.length
                    });
                }
            }

            game.winningCells = originalWinningCells;

            if (threats.length > 0) {
                threats.sort(function(a, b) { return b.level - a.level; });
                
                var topThreat = threats[0];
                console.log(`最優先脅威: ${topThreat.type}${topThreat.length}連 (脅威レベル:${topThreat.level})`);
                
                var blockPos = topThreat.positions[0];
                console.log(`3連脅威阻止手: (${blockPos[0]}, ${blockPos[1]})`);
                return blockPos;
            }

            console.log("3連脅威なし");
            return null;
        }

        // 中央付近の価値の高い手を探す
        function findCenterMove() {
            console.log("中央制圧手検索開始");
            
            var centerCol = Math.floor(GRID_WIDTH / 2);
            var validMoves = getAllValidMoves();
            
            if (validMoves.length === 0) {
                console.log("中央制圧手なし - 有効手が0個");
                return null;
            }
            
            validMoves.sort(function(a, b) {
                var distA = Math.abs(a[1] - centerCol);
                var distB = Math.abs(b[1] - centerCol);
                return distA - distB;
            });
            
            console.log(`中央制圧手選択: (${validMoves[0][0]}, ${validMoves[0][1]}) - 中央からの距離: ${Math.abs(validMoves[0][1] - centerCol)}`);
            return validMoves[0];
        }

        // 2手勝利の可能性を探す
        function findTwoMoveWin(player) {
            console.log(`2手勝利検索開始 - プレイヤー${player}`);
            
            var originalWinningCells = game.winningCells.slice();
            var validMoves = getAllValidMoves();
            
            for (var i = 0; i < validMoves.length; i++) {
                var move = validMoves[i];
                var row = move[0];
                var col = move[1];
                
                game.grid[row][col] = player;
                
                var hasWinningFollow = false;
                for (var row2 = 0; row2 < GRID_HEIGHT; row2++) {
                    for (var col2 = 0; col2 < GRID_WIDTH; col2++) {
                        if (game.grid[row2][col2] !== 0) continue;
                        if (!isValidPlacement(row2, col2)) continue;
                        
                        game.grid[row2][col2] = player;
                        var canWin = checkWin(row2, col2);
                        game.grid[row2][col2] = 0;
                        
                        if (canWin) {
                            hasWinningFollow = true;
                            break;
                        }
                    }
                    if (hasWinningFollow) break;
                }
                
                game.grid[row][col] = 0;
                
                if (hasWinningFollow) {
                    console.log(`2手勝利の起点発見: (${row}, ${col}) - プレイヤー${player}`);
                    game.winningCells = originalWinningCells;
                    return [row, col];
                }
            }
            
            game.winningCells = originalWinningCells;
            console.log("2手勝利なし");
            return null;
        }

        // 連続ブロック検出
        function findConsecutiveBlocks(player, length) {
            var results = [];
            var directions = [
                [0, 1],  // 横
                [1, 0],  // 縦
                [1, 1],  // 斜め右下
                [1, -1]  // 斜め左下
            ];

            for (var row = 0; row < GRID_HEIGHT; row++) {
                for (var col = 0; col < GRID_WIDTH; col++) {
                    if (game.grid[row][col] !== player) continue;

                    for (var d = 0; d < directions.length; d++) {
                        var dr = directions[d][0];
                        var dc = directions[d][1];
                        var line = [[row, col]];
                        
                        for (var i = 1; i < WIN_COUNT; i++) {
                            var r = row + dr * i;
                            var c = col + dc * i;
                            if (r >= 0 && r < GRID_HEIGHT && c >= 0 && c < GRID_WIDTH && 
                                game.grid[r][c] === player) {
                                line.push([r, c]);
                            } else {
                                break;
                            }
                        }

                        if (line.length >= length) {
                            var extendable = [];
                            
                            var frontR = row - dr;
                            var frontC = col - dc;
                            if (frontR >= 0 && frontR < GRID_HEIGHT && frontC >= 0 && frontC < GRID_WIDTH && 
                                game.grid[frontR][frontC] === 0) {
                                extendable.push([frontR, frontC]);
                            }
                            
                            var backR = row + dr * line.length;
                            var backC = col + dc * line.length;
                            if (backR >= 0 && backR < GRID_HEIGHT && backC >= 0 && backC < GRID_WIDTH && 
                                game.grid[backR][backC] === 0) {
                                extendable.push([backR, backC]);
                            }

                            results.push({
                                line: line,
                                direction: d,
                                extendable: extendable,
                                isGround: row === GRID_HEIGHT - 1 || (row + dr * (line.length - 1)) === GRID_HEIGHT - 1
                            });
                        }
                    }
                }
            }

            return results;
        }

        // 脅威評価
        function evaluateThreat(consecutiveInfo, player) {
            var length = consecutiveInfo.line.length;
            var extendable = consecutiveInfo.extendable;
            var isGround = consecutiveInfo.isGround;
            var direction = consecutiveInfo.direction;

            var score = 0;

            if (length === 4) {
                score = 1000;
                if (extendable.length >= 1) {
                    score += 500;
                }
            } else if (length === 3) {
                if (direction === 1) {
                    score = 800;
                } else if (direction === 0 && isGround) {
                    score = 850;
                } else if (direction === 0) {
                    if (extendable.length >= 2) {
                        score = 700;
                    } else if (extendable.length === 1) {
                        score = 500;
                    }
                } else {
                    if (extendable.length >= 2) {
                        score = 600;
                    } else if (extendable.length === 1) {
                        score = 400;
                    }
                }
            } else if (length === 2) {
                score = length * 10;
            }

            return score;
        }

        // 防御必要数計算
        function calculateDefenseRequired(consecutiveInfo, player) {
            var length = consecutiveInfo.line.length;
            var extendable = consecutiveInfo.extendable;
            var direction = consecutiveInfo.direction;
            var isGround = consecutiveInfo.isGround;

            if (length === 4) {
                var requiredBlocks = 0;
                for (var i = 0; i < extendable.length; i++) {
                    var pos = extendable[i];
                    if (isValidPlacement(pos[0], pos[1])) {
                        requiredBlocks++;
                    }
                }
                return Math.min(requiredBlocks, 2);
            } else if (length === 3) {
                if (direction === 1) {
                    return 1;
                } else if (direction === 0 && isGround) {
                    return 2;
                } else {
                    var validExtendable = 0;
                    for (var i = 0; i < extendable.length; i++) {
                        var pos = extendable[i];
                        if (isValidPlacement(pos[0], pos[1])) {
                            validExtendable++;
                        }
                    }
                    return Math.min(validExtendable, 2);
                }
            }

            return 1;
        }

        // 複数脅威作成手を探す
        function findMultipleThreatMove(player) {
            console.log(`複数脅威検索開始 - プレイヤー${player}`);
            
            var originalWinningCells = game.winningCells.slice();
            var validMoves = getAllValidMoves();
            var bestMove = null;
            var maxThreats = 0;

            for (var i = 0; i < validMoves.length; i++) {
                var move = validMoves[i];
                var row = move[0];
                var col = move[1];

                game.grid[row][col] = player;

                var threats = findConsecutiveBlocks(player, 3);
                var totalThreatScore = 0;
                var defenseRequired = 0;

                for (var t = 0; t < threats.length; t++) {
                    var threat = threats[t];
                    totalThreatScore += evaluateThreat(threat, player);
                    defenseRequired += calculateDefenseRequired(threat, player);
                }

                if (threats.length >= 2 && defenseRequired >= 3) {
                    console.log(`複数脅威発見: (${row}, ${col}) - 脅威数:${threats.length}, 防御必要数:${defenseRequired}`);
                    
                    if (defenseRequired > maxThreats || (defenseRequired === maxThreats && totalThreatScore > 0)) {
                        maxThreats = defenseRequired;
                        bestMove = [row, col];
                    }
                }

                game.grid[row][col] = 0;
            }

            game.winningCells = originalWinningCells;
            
            if (bestMove) {
                console.log(`複数脅威手選択: (${bestMove[0]}, ${bestMove[1]}) - 防御必要数:${maxThreats}`);
            } else {
                console.log("複数脅威手なし");
            }
            
            return bestMove;
        }

        // 高脅威手を探す
        function findHighThreatMove(player) {
            console.log(`高脅威手検索開始 - プレイヤー${player}`);
            
            var originalWinningCells = game.winningCells.slice();
            var validMoves = getAllValidMoves();
            var bestMove = null;
            var maxScore = 0;

            for (var i = 0; i < validMoves.length; i++) {
                var move = validMoves[i];
                var row = move[0];
                var col = move[1];

                game.grid[row][col] = player;

                var threats = findConsecutiveBlocks(player, 2);
                var totalScore = 0;

                for (var t = 0; t < threats.length; t++) {
                    totalScore += evaluateThreat(threats[t], player);
                }

                if (totalScore > maxScore) {
                    maxScore = totalScore;
                    bestMove = [row, col];
                }

                game.grid[row][col] = 0;
            }

            game.winningCells = originalWinningCells;
            
            if (bestMove && maxScore > 100) {
                console.log(`高脅威手選択: (${bestMove[0]}, ${bestMove[1]}) - スコア:${maxScore}`);
                return bestMove;
            }
            
            console.log("有効な高脅威手なし");
            return null;
        }

        // 相手の複数脅威を阻止
        function findMultipleThreatBlock(player) {
            var opponent = player === 1 ? 2 : 1;
            console.log(`相手複数脅威阻止検索 - 相手プレイヤー${opponent}`);
            
            var opponentThreats = findConsecutiveBlocks(opponent, 3);
            if (opponentThreats.length < 2) {
                return null;
            }

            var totalDefenseRequired = 0;
            for (var i = 0; i < opponentThreats.length; i++) {
                totalDefenseRequired += calculateDefenseRequired(opponentThreats[i], opponent);
            }

            if (totalDefenseRequired >= 3) {
                console.log(`相手の複数脅威検出 - 防御必要数:${totalDefenseRequired}`);
                
                var mostDangerous = null;
                var maxScore = 0;
                
                for (var i = 0; i < opponentThreats.length; i++) {
                    var threat = opponentThreats[i];
                    var score = evaluateThreat(threat, opponent);
                    if (score > maxScore) {
                        maxScore = score;
                        mostDangerous = threat;
                    }
                }

                if (mostDangerous && mostDangerous.extendable.length > 0) {
                    var blockPos = mostDangerous.extendable[0];
                    if (isValidPlacement(blockPos[0], blockPos[1])) {
                        console.log(`複数脅威阻止手: (${blockPos[0]}, ${blockPos[1]})`);
                        return blockPos;
                    }
                }
            }

            return null;
        }

        // ブロック配置処理
        function placePiece(row, col, isAIMove) {
            try {
                if (row < 0 || row >= GRID_HEIGHT || col < 0 || col >= GRID_WIDTH) {
                    return;
                }
                
                if (!game.gameActive || game.animating || game.remainingBlocks <= 0) {
                    return;
                }
                
                if (game.isAI && game.currentPlayer === game.aiPlayer && !isAIMove) {
                    return;
                }
                
                if (game.grid[row][col] !== 0) {
                    if (!isAIMove) {
                        showAlert("そのマスには既にブロックがあります！");
                    }
                    return;
                }
                
                if (row < GRID_HEIGHT - 1 && game.grid[row + 1][col] === 0) {
                    if (!isAIMove) {
                        showAlert("この位置には下に支えがありません！");
                    }
                    return;
                }
                
                if (row === GRID_HEIGHT - 1 && !isValidGroundPlacement(col)) {
                    if (!isAIMove) {
                        showAlert("地面に置くには隣接ブロックが必要です！");
                    }
                    return;
                }
                
                game.animating = true;
                
                setTimeout(function () {
                    game.grid[row][col] = game.currentPlayer;
                    game.remainingBlocks--;
                    
                    console.log(`ブロック配置完了 - プレイヤー${game.currentPlayer}, 残り${game.remainingBlocks}個`);
                    
                    if (checkWin(row, col)) {
                        game.showingWin = true;
                        console.log("勝利確定！勝利ライン表示開始");
                        
                        showWinningCells();
                        updateGrid();
                        
                        setTimeout(async function() {
                            await endGame(game.currentPlayer);
                        }, 3000);
                        return;
                    }
                    
                    if (game.remainingBlocks <= 0) {
                        setTimeout(function () {
                            clearInterval(game.timer);
                            
                            game.currentPlayer = game.currentPlayer === 1 ? 2 : 1;
                            game.turnCount++;
                            
                            game.remainingBlocks = game.turnCount === 1 ? BLOCKS_PER_TURN : BLOCKS_PER_TURN;
                            
                            if (game.turnCount === 0) {
                                game.timeLeft = 30;
                            } else if (game.turnCount === 1) {
                                game.timeLeft = 45;
                            } else {
                                game.timeLeft = 60;
                            }
                            
                            console.log(`ターン交代 - プレイヤー${game.currentPlayer}, ターン${game.turnCount}`);
                            
                            // ターン交代アニメーション追加
                            showTurnChangeAnimation(game.currentPlayer);
                            
                            startTimer();
                            updateDisplay();
                            
                            if (game.isAI && game.currentPlayer === game.aiPlayer) {
                                setTimeout(cpuPlay, 800);
                            }
                        }, 500);
                    }
                    
                    game.animating = false;
                    updateDisplay();
                    
                    checkAndExtendGrid();
                    
                }, 300);
                
            } catch (error) {
                console.error("ブロック配置でエラー:", error);
                game.animating = false;
                showAlert("エラーが発生しました。");
            }
        }

        // フィールド拡張機能
        function checkAndExtendGrid() {
            var needsUpdate = false;

            for (var row = 0; row < GRID_HEIGHT; row++) {
                if (game.grid[row][0] !== 0) {
                    console.log("左端拡張実行");
                    extendGridLeft();
                    needsUpdate = true;
                    break;
                }
            }

            for (var row = 0; row < GRID_HEIGHT; row++) {
                if (game.grid[row][GRID_WIDTH - 1] !== 0) {
                    console.log("右端拡張実行");
                    extendGridRight();
                    needsUpdate = true;
                    break;
                }
            }

            for (var col = 0; col < GRID_WIDTH; col++) {
                if (game.grid[0][col] !== 0) {
                    console.log("上端拡張実行");
                    extendGridTop();
                    needsUpdate = true;
                    break;
                }
            }

            if (needsUpdate) {
                createGrid();
                updateDisplay();
            }
        }

        function extendGridLeft() {
            for (var row = 0; row < GRID_HEIGHT; row++) {
                game.grid[row].unshift(0);
            }
            GRID_WIDTH++;
            console.log(`左拡張完了 - 新サイズ: ${GRID_WIDTH}x${GRID_HEIGHT}`);
        }

        function extendGridRight() {
            for (var row = 0; row < GRID_HEIGHT; row++) {
                game.grid[row].push(0);
            }
            GRID_WIDTH++;
            console.log(`右拡張完了 - 新サイズ: ${GRID_WIDTH}x${GRID_HEIGHT}`);
        }

        function extendGridTop() {
            var newRow = new Array(GRID_WIDTH).fill(0);
            game.grid.unshift(newRow);
            GRID_HEIGHT++;
            console.log(`上拡張完了 - 新サイズ: ${GRID_WIDTH}x${GRID_HEIGHT}`);
        }

        function updateGridTemplate() {
            var gridElement = document.getElementById('gameGrid');
            if (gridElement) {
                gridElement.style.gridTemplateColumns = `repeat(${GRID_WIDTH}, 32px)`;
            }
        }

        async function cpuPlay() {
            if (!game.gameActive || game.currentPlayer !== game.aiPlayer || !game.isAI || game.showingWin) {
                console.log("AI動作停止");
                return;
            }

            console.log(`AI動作開始 Lv${aiLevel} - 配置予定ブロック数:`, game.remainingBlocks);
            
            game.aiThinking = true;

            // LEVEL6 AIのターン開始
            if (aiLevel === 6 && level6AI && level6AI.isInitialized) {
                level6AI.startGame(game, game.aiPlayer); 
                level6AI.startTurn(game, game.aiPlayer);
            }
            
            let placed = 0;
            const maxBlocks = game.remainingBlocks;

            async function placeOneBlock() {
                if (placed >= maxBlocks || !game.gameActive || game.currentPlayer !== game.aiPlayer) {
                    console.log("AI配置完了");

                    // LEVEL6 AIのターン終了（ゲーム継続中）
                    if (aiLevel === 6 && level6AI && level6AI.isInitialized) {
                        level6AI.endTurn(game, 'continue');
                    }
                    
                    game.aiThinking = false;
                    return;
                }

                let chosenMove = null;

                if (aiLevel === 1) {
                    chosenMove = getRandomMove();
                    console.log("Lv1（ランダム）戦略で手を選択");
                    
                } else if (aiLevel === 2) {
                    console.log("=== レベル2AI動作開始 ===");
                    
                    try {
                        var winMove = findWinningMove(game.aiPlayer);
                        
                        if (winMove) {
                            console.log("レベル2: 勝利手選択");
                            chosenMove = winMove;
                        } else {
                            var blockMove = findBlockingMove(game.aiPlayer);
                            
                            if (blockMove) {
                                console.log("レベル2: 阻止手選択");
                                chosenMove = blockMove;
                            } else {
                                chosenMove = getRandomMove();
                                console.log("レベル2: ランダム手選択");
                            }
                        }
                    } catch (error) {
                        console.error("レベル2AI処理でエラー:", error);
                        chosenMove = getRandomMove();
                    }
                    
                } else if (aiLevel === 3) {
                    console.log("=== レベル3AI動作開始 ===");
                    
                    try {
                        var winMove = findWinningMove(game.aiPlayer);
                        
                        if (winMove) {
                            console.log("レベル3: 勝利手選択");
                            chosenMove = winMove;
                        } else {
                            var blockMove = findBlockingMove(game.aiPlayer);
                            
                            if (blockMove) {
                                console.log("レベル3: 阻止手選択");
                                chosenMove = blockMove;
                            } else {
                                var twoMoveWin = findTwoMoveWin(game.aiPlayer);
                                
                                if (twoMoveWin) {
                                    console.log("レベル3: 2手勝利手選択");
                                    chosenMove = twoMoveWin;
                                } else {
                                    var opponent = game.aiPlayer === 1 ? 2 : 1;
                                    var opponentTwoMoveWin = findTwoMoveWin(opponent);
                                    
                                    if (opponentTwoMoveWin) {
                                        console.log("レベル3: 相手2手勝利阻止");
                                        chosenMove = opponentTwoMoveWin;
                                    } else {
                                        var centerMove = findCenterMove();
                                        
                                        if (centerMove) {
                                            console.log("レベル3: 中央制圧手選択");
                                            chosenMove = centerMove;
                                        } else {
                                            chosenMove = getRandomMove();
                                        }
                                    }
                                }
                            }
                        }
                    } catch (error) {
                        console.error("レベル3AI処理でエラー:", error);
                        chosenMove = getRandomMove();
                    }
                    
                } else if (aiLevel === 4) {
                    console.log("=== レベル4AI動作開始（防御最優先）===");
                    
                    try {
                        console.log("レベル4: 勝利手検索中...");
                        var winMove = findWinningMove(game.aiPlayer);
                        
                        if (winMove) {
                            console.log("レベル4: 即座勝利手選択");
                            chosenMove = winMove;
                        } else {
                            console.log("レベル4: 即座勝利阻止検索中...");
                            var blockMove = findBlockingMove(game.aiPlayer);
                            
                            if (blockMove) {
                                console.log("レベル4: 相手即座勝利阻止");
                                chosenMove = blockMove;
                            } else {
                                console.log("レベル4: 4連緊急阻止検索中...");
                                var fourRowThreat = findFourInARowThreat(game.aiPlayer);
                                
                                if (fourRowThreat) {
                                    console.log("レベル4: ★緊急★ 4連阻止手選択");
                                    chosenMove = fourRowThreat;
                                } else {
                                    console.log("レベル4: 3連脅威阻止検索中...");
                                    var threatBlockMove = findThreeInARowThreat(game.aiPlayer);
                                    
                                    if (threatBlockMove) {
                                        console.log("レベル4: 3連脅威阻止手選択");
                                        chosenMove = threatBlockMove;
                                    } else {
                                        console.log("レベル4: 複数脅威手検索中...");
                                        var multipleThreatMove = findMultipleThreatMove(game.aiPlayer);
                                        
                                        if (multipleThreatMove) {
                                            console.log("レベル4: 複数脅威作成手選択");
                                            chosenMove = multipleThreatMove;
                                        } else {
                                            console.log("レベル4: 相手複数脅威阻止検索中...");
                                            var blockMultipleThreat = findMultipleThreatBlock(game.aiPlayer);
                                            
                                            if (blockMultipleThreat) {
                                                console.log("レベル4: 相手複数脅威阻止");
                                                chosenMove = blockMultipleThreat;
                                            } else {
                                                console.log("レベル4: 高脅威手検索中...");
                                                var highThreatMove = findHighThreatMove(game.aiPlayer);
                                                
                                                if (highThreatMove) {
                                                    console.log("レベル4: 高脅威手選択");
                                                    chosenMove = highThreatMove;
                                                } else {
                                                    console.log("レベル4: 2手勝利検索中...");
                                                    var twoMoveWin = findTwoMoveWin(game.aiPlayer);
                                                    
                                                    if (twoMoveWin) {
                                                        console.log("レベル4: 2手勝利手選択");
                                                        chosenMove = twoMoveWin;
                                                    } else {
                                                        console.log("レベル4: 相手2手勝利阻止検索中...");
                                                        var opponent = game.aiPlayer === 1 ? 2 : 1;
                                                        var opponentTwoMoveWin = findTwoMoveWin(opponent);
                                                        
                                                        if (opponentTwoMoveWin) {
                                                            console.log("レベル4: 相手2手勝利阻止");
                                                            chosenMove = opponentTwoMoveWin;
                                                        } else {
                                                            console.log("レベル4: 縦2連+本命攻撃検索中...");
                                                            var verticalComboMove = findVerticalDoublePlusThreatMove(game.aiPlayer);
                                                            
                                                            if (verticalComboMove) {
                                                                console.log("レベル4: 縦2連+本命攻撃選択");
                                                                chosenMove = verticalComboMove;
                                                            } else {
                                                                console.log("レベル4: 相手縦2連阻止検索中...");
                                                                var verticalBlockMove = findVerticalDoubleBlock(game.aiPlayer);
                                                                
                                                                if (verticalBlockMove) {
                                                                    console.log("レベル4: 相手縦2連阻止選択");
                                                                    chosenMove = verticalBlockMove;
                                                                } else {
                                                                    console.log("レベル4: 縦2連作成検索中...");
                                                                    var verticalDoubleMove = findVerticalDoubleMove(game.aiPlayer);
                                                                    
                                                                    if (verticalDoubleMove) {
                                                                        console.log("レベル4: 縦2連作成手選択");
                                                                        chosenMove = verticalDoubleMove;
                                                                    } else {
                                                                        console.log("レベル4: 中央制圧検索中...");
                                                                        var centerMove = findCenterMove();
                                                                        
                                                                        if (centerMove) {
                                                                            console.log("レベル4: 中央制圧手選択");
                                                                            chosenMove = centerMove;
                                                                        } else {
                                                                            console.log("レベル4: ランダム手選択");
                                                                            chosenMove = getRandomMove();
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } catch (error) {
                        console.error("レベル4AI処理でエラー:", error);
                        chosenMove = getRandomMove();
                        console.log("レベル4: エラー後のフォールバック");
                    }
                    
                } else if (aiLevel === 6) {
                    console.log("=== レベル6 機械学習AI動作開始 ===");
                    
                    try {
                        if (!level6AI) {
                            level6AI = new Level6AI();
                            await level6AI.initializeModel();
                        }
                        
                        if (level6AI && level6AI.isInitialized) {
                            const validMoves = getAllValidMoves();
                            chosenMove = await level6AI.selectAction(game, game.aiPlayer, validMoves);
                            console.log(`LEVEL6選択: (${chosenMove?.[0]}, ${chosenMove?.[1]})`);
                        } else {
                            chosenMove = getRandomMove();
                            console.log("LEVEL6フォールバック: ランダム");
                        }
                    } catch (error) {
                        console.error("レベル6AI処理でエラー:", error);
                        chosenMove = getRandomMove();
                    }
                } else {
                    chosenMove = getRandomMove();
                    console.log("デフォルト（ランダム）戦略で手を選択");
                }

                console.log('AI選択した手:', chosenMove);

                if (chosenMove) {
                    console.log(`AI配置実行: (${chosenMove[0]}, ${chosenMove[1]})`);
                    // LEVEL6 AIにアクションを記録
                    if (aiLevel === 6 && level6AI && level6AI.isInitialized) {
                        level6AI.recordAction(chosenMove, game, game.aiPlayer);
                    }
                    placePiece(chosenMove[0], chosenMove[1], true);
                    placed++;
                    setTimeout(placeOneBlock, 600);
                } else {
                    console.warn("AIが有効な手を見つけられませんでした");
                    game.aiThinking = false;
                }
            }

            placeOneBlock();
        }

        // Level4用の不足している関数群
        function findFourInARowThreat(player) {
            return findThreeInARowThreat(player);
        }

        function findDiagonalThreat(player) {
            return null;
        }

        function findFutureThreats(player) {
            return null;
        }

        function findAntiEncirclementMove(player) {
            return null;
        }

        function findEncirclementMove(player) {
            return null;
        }

        function findClusterMove(player) {
            return null;
        }

        // 勝利チェック
        function checkWin(row, col) {
            var player = game.grid[row][col];
            var directions = [
                [0, 1],  // 横
                [1, 0],  // 縦
                [1, 1],  // 斜め右下
                [1, -1]  // 斜め左下
            ];

            for (var d = 0; d < directions.length; d++) {
                var dr = directions[d][0];
                var dc = directions[d][1];
                var line = [[row, col]];
                
                for (var i = 1; i < WIN_COUNT; i++) {
                    var r = row - dr * i;
                    var c = col - dc * i;
                    if (r >= 0 && r < GRID_HEIGHT && c >= 0 && c < GRID_WIDTH && 
                        game.grid[r][c] === player) {
                        line.unshift([r, c]);
                    } else {
                        break;
                    }
                }
                
                for (var i = 1; i < WIN_COUNT; i++) {
                    var r = row + dr * i;
                    var c = col + dc * i;
                    if (r >= 0 && r < GRID_HEIGHT && c >= 0 && c < GRID_WIDTH && 
                        game.grid[r][c] === player) {
                        line.push([r, c]);
                    } else {
                        break;
                    }
                }
                
                if (line.length >= WIN_COUNT) {
                    game.winningCells = line;
                    return true;
                }
            }
            
            return false;
        }

        // ターン交代アニメーション表示
        function showTurnChangeAnimation(newPlayer) {
            // 既存の通知を削除
            const existingNotification = document.querySelector('.turn-notification');
            if (existingNotification) {
                existingNotification.remove();
            }

            // プレイヤー要素にアニメーション追加
            const playerElement = document.getElementById(`player${newPlayer}`);
            if (playerElement) {
                playerElement.classList.add('turn-change');
                setTimeout(() => {
                    playerElement.classList.remove('turn-change');
                }, 1200);
            }

            // ターン交代通知作成
            const notification = document.createElement('div');
            notification.className = 'turn-notification';
            
            let playerName;
            if (game.isAI && game.aiPlayer === newPlayer) {
                playerName = `AI (Lv${aiLevel})のターン`;
                notification.classList.add('ai-turn');
            } else {
                playerName = `プレイヤー${newPlayer}のターン`;
            }
            
            notification.innerHTML = `
                <div style="font-size: 16px; margin-bottom: 5px;">🔄 ターン交代</div>
                <div style="font-size: 20px; font-weight: bold;">${playerName}</div>
            `;
            
            document.body.appendChild(notification);
            
            // 1.5秒後に自動削除
            setTimeout(() => {
                if (notification && notification.parentNode) {
                    notification.remove();
                }
            }, 1500);
            
            console.log(`ターン交代アニメーション表示: ${playerName}`);
        }
        
        // アラート表示
        function showAlert(message) {
            var existingAlert = document.querySelector('.alert');
            if (existingAlert) {
                existingAlert.remove();
            }
            
            var alert = document.createElement('div');
            alert.className = 'alert';
            alert.textContent = message;
            document.body.appendChild(alert);
            
            setTimeout(function() {
                alert.remove();
            }, 2000);
        }

        // ゲーム終了
      async function endGame(winner) {

          
            console.log(`ゲーム終了処理開始 - 勝者: ${winner}`);
            
            game.gameActive = false;
            clearInterval(game.timer);
            
            clearWinningCells();
            game.aiThinking = false;
        
            // LEVEL6 AI学習処理
            if (level6AI && aiLevel === 6 && level6AI.isInitialized) {
                let result = 'draw';
                if (winner === game.aiPlayer) {
                    result = 'win';
                } else if (winner !== 0 && winner !== game.aiPlayer) {
                    result = 'lose';
                }
                
                // await使用可能
                await level6AI.onGameEnd(result, game.aiPlayer);
                
                // メモリ数の更新
                const memoryElement = document.getElementById('memoryCount');
                if (memoryElement) {
                    memoryElement.textContent = level6AI.memory.length;
                }
            }


            var modal = document.getElementById('gameModal');
            var message = document.getElementById('modalMessage');
            var title = document.getElementById('modalTitle');
            var icon = document.getElementById('winnerIcon');

            if (winner === 1) {
                if (game.isAI && game.aiPlayer === 1) {
                    title.textContent = '🤖 AIの勝利！';
                } else {
                    title.textContent = '🎉 プレイヤー1の勝利！';
                }
                icon.style.background = '#ef4444';
            } else if (winner === 2) {
                if (game.isAI && game.aiPlayer === 2) {
                    title.textContent = '🤖 AIの勝利！';
                } else {
                    title.textContent = '🎉 プレイヤー2の勝利！';
                }
                icon.style.background = '#3b82f6';
            } else {
                title.textContent = '🤝 ゲーム終了';
                icon.style.background = '#9ca3af';
            }

            // AI進化メッセージ
            if (game.isAI && aiLevel === 6 && level6AI) {
                const evolutionMsg = getEvolutionMessage();
                message.textContent = evolutionMsg + '\n\n再戦でAIをさらに成長させますか？';
            } else {
                message.textContent = 'ゲームが終了しました。再戦しますか？';
            }
            modal.style.display = 'block';
            
            console.log("ゲーム終了モーダル表示完了");
        }

        async function endGameNow() {
            
            await endGame(0);
        }

        // LEVEL6制御関数
        function onAILevelChange() {
            const level = parseInt(document.getElementById('aiLevelSelect').value);
            const mlContainer = document.getElementById('mlStatusContainer');
            
            if (level === 6) {
                mlContainer.style.display = 'block';
                if (!level6AI) {
                    level6AI = new Level6AI();
                    level6AI.initializeModel();
                }
            } else {
                mlContainer.style.display = 'none';
            }
        }

        function toggleMLTraining() {
            if (level6AI) {
                level6AI.toggleTraining();
                const btn = document.getElementById('mlToggleBtn');
                btn.textContent = `学習モード: ${level6AI.isTraining ? 'ON' : 'OFF'}`;
            }
        }

        function resetMLAI() {
            if (level6AI && confirm('AI学習データをリセットしますか？')) {
                level6AI.reset();
            }
        }

        function exportMLData() {
            if (level6AI) {
                const data = {
                    // 基本統計
                    gamesPlayed: level6AI.gamesPlayed,
                    wins: level6AI.wins,
                    winRate: level6AI.winRate,
                    epsilon: level6AI.epsilon,
                    
                    // 学習履歴
                    lossHistory: level6AI.lossHistory,
                    winRateHistory: level6AI.winRateHistory,
                    rewardHistory: level6AI.rewardHistory,
                    
                    // メタデータ
                    memorySize: level6AI.memory.length,
                    maxMemory: level6AI.maxMemory,
                    batchSize: level6AI.batchSize,
                    exportTime: new Date().toISOString(),
                    
                    // 詳細学習データ（最新100件のみ）
                    recentMemory: level6AI.memory.slice(-100),
                    
                    // 成長段階
                    stage: level6AI.gamesPlayed > 200 ? 'マスター' :
                           level6AI.gamesPlayed > 100 ? 'エキスパート' :
                           level6AI.gamesPlayed > 60 ? '熟練' :
                           level6AI.gamesPlayed > 30 ? '成長期' :
                           level6AI.gamesPlayed > 15 ? '学習中' :
                           level6AI.gamesPlayed > 5 ? '幼児' : '誕生'
                };
                
                const blob = new Blob([JSON.stringify(data, null, 2)], {
                    type: 'application/json'
                });
                
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `level6_ai_data_${level6AI.gamesPlayed}games_${data.stage}.json`;
                a.click();
                URL.revokeObjectURL(url);
                
                console.log(`AIデータエクスポート完了: ${level6AI.gamesPlayed}戦, 勝率${(level6AI.winRate*100).toFixed(1)}%`);
            }
        }

window.startGame = startGame;
window.onAILevelChange = onAILevelChange;
window.toggleMLTraining = toggleMLTraining;
window.resetMLAI = resetMLAI;
window.exportMLData = exportMLData;
window.showLearningGraph = showLearningGraph;
window.saveMLManually = saveMLManually;
window.showStart = showStart;
window.endGameNow = endGameNow;
        function getEvolutionMessage() {
            if (!level6AI) return 'ゲームが終了しました。';
            
            const games = level6AI.gamesPlayed;
            const winRate = level6AI.winRate;
            
            if (games <= 5) {
                return `🍼 AIは${games}回目の体験でした。まだ学習を始めたばかりです。`;
            } else if (games <= 15) {
                return `👶 AIは${games}戦の経験を積みました。基本を覚え始めています。`;
            } else if (games <= 30) {
                return `🧒 AIは${games}戦で勝率${(winRate*100).toFixed(1)}%です。戦略を学習中です。`;
            } else if (games <= 60) {
                return `🧑‍🎓 AIは${games}戦で勝率${(winRate*100).toFixed(1)}%を達成。かなり成長しました！`;
            } else if (games <= 100) {
                return `🏆 AIは${games}戦の豊富な経験で勝率${(winRate*100).toFixed(1)}%。熟練の域です！`;
            } else {
                return `🎯 AIは${games}戦のマスタークラス、勝率${(winRate*100).toFixed(1)}%。あなたの最強の対戦相手です！`;
            }
        }

        function showLearningGraph() {
            if (!level6AI || level6AI.winRateHistory.length < 5) {
                alert('学習データが不足しています。5戦以上プレイしてください。');
                return;
            }
            
            const canvas = document.createElement('canvas');
            canvas.width = 400;
            canvas.height = 300;
            canvas.style.border = '1px solid #ddd';
            canvas.style.borderRadius = '5px';
            
            const ctx = canvas.getContext('2d');
            
            // 背景
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, 400, 300);
            
            // 勝率グラフ
            const winRates = level6AI.winRateHistory.slice(-50); // 最新50件
            const maxY = 280;
            const minY = 20;
            const maxX = 380;
            const minX = 20;
            
            ctx.strokeStyle = '#3b82f6';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            for (let i = 0; i < winRates.length; i++) {
                const x = minX + (i / (winRates.length - 1)) * (maxX - minX);
                const y = maxY - (winRates[i] * (maxY - minY));
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();
            
            // 軸とラベル
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 1;
            
            // Y軸
            ctx.beginPath();
            ctx.moveTo(minX, minY);
            ctx.lineTo(minX, maxY);
            ctx.stroke();
            
            // X軸
            ctx.beginPath();
            ctx.moveTo(minX, maxY);
            ctx.lineTo(maxX, maxY);
            ctx.stroke();
            
            // ラベル
            ctx.fillStyle = '#333';
            ctx.font = '12px Arial';
            ctx.fillText('勝率', 5, 15);
            ctx.fillText('0%', 5, maxY);
            ctx.fillText('100%', 5, minY + 15);
            ctx.fillText('対戦履歴（最新50戦）', 150, 295);
            
            // モーダル表示
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.7); z-index: 2000; display: flex;
                align-items: center; justify-content: center;
            `;
            
            const content = document.createElement('div');
            content.style.cssText = `
                background: white; padding: 20px; border-radius: 10px;
                text-align: center; max-width: 90%;
            `;
            
            const title = document.createElement('h3');
            title.textContent = 'LEVEL6 AI 学習進化グラフ';
            title.style.margin = '0 0 15px 0';
            
            const closeBtn = document.createElement('button');
            closeBtn.textContent = '閉じる';
            closeBtn.style.cssText = `
                margin-top: 15px; padding: 8px 16px; background: #3b82f6;
                color: white; border: none; border-radius: 5px; cursor: pointer;
            `;
            closeBtn.onclick = () => document.body.removeChild(modal);
            
            content.appendChild(title);
            content.appendChild(canvas);
            content.appendChild(closeBtn);
            modal.appendChild(content);
            document.body.appendChild(modal);
        }

        async function saveMLManually() {
            if (level6AI && level6AI.isInitialized) {
                try {
                    await level6AI.saveModel();
                    level6AI.saveStatistics();
                    alert('AIデータを手動保存しました！');
                } catch (error) {
                    alert('保存に失敗しました: ' + error.message);
                }
            } else {
                alert('AIが初期化されていません。');
            }
        }


    </script>
</body>
</html>
